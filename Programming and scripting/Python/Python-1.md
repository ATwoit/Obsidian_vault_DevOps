```Python
print ("Hello World")
```

Ссылка для расформулировки - https://pythontutor.com/

## Языки программирования

- *Компилируемые*
- *Интерпретируемые*

==Компилируемый==
Перед выполнением её нужно полностью проверить на наличие синтаксических ошибок и уже после этого перевести в понятную для компьютера форму — **машинный код**. Это делает специальная программа, которая называется **компилятором**.

==Интерпретируемый==
Не переводится в машинный код целиком. Вместо этого специальная программа, которая называется **интерпретатором**, идет по коду, анализирует его и выполняет каждую отдельную команду.

|        | Компилируемые | Интерпретируемые |
| ------ | ------------- | ---------------- |
| C#     | +             | +                |
| Java   | +             | +                |
| Python |               | +                |
| PHP    |               | +                |
| Ruby   |               | +                |
| С      | +             |                  |
| C++    | +             |                  |
| Pascal | +             |                  |

## Задачи, решаемые с помощью Python

1. ==**Системное программирование.**==Встроенные в  Python интерфейсы доступа к службам операционных систем делают его идеальным инструментом для создания переносимых программ и утилит системного администрирования;

2. ==**Графические приложения.**== Простота Python и быстрота разработки делают его отличным средством создания графического интерфейса. В состав Python входит стандартный объектно-ориентированный интерфейс к GUI API;

3. ==**Веб-приложения.**== С помощью дополнительных [фреймворков](https://web-creator.ru/articles/about_frameworks) на языке Python (Django, Flask, Pyramid) можно создавать полнофункциональные сайты;

4. ==**Веб-сценарии.**== Python поставляется вместе со стандартными интернет-модулями, которые позволяют программам выполнять разнообразные сетевые операции как в режиме клиента, так и в режиме сервера;

5. ==**Интеграция компонентов.**== Возможность Python расширяться и встраиваться в системы на языке C++ делает его удобным для описания поведения других систем и компонентов;

6. ==**Приложения баз данных.**== В Python имеются интерфейсы доступа ко всем основным [реляционным](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85) базам данных: Sybase, Oracle, Informix, ODBC, MySQL, PostgreSQL, SQLite и многим другим. С их помощью можно создавать приложения баз данных.

## Установка VS Code

Так же вот ссылка для Python - https://www.python.org/

Вот ссылка самой программы - https://code.visualstudio.com/

Весь путь установки есть на самом сайте, а так же есть в курсе на Stepik

## Ввод-Вывод данных 

[[#1. Вывод данных, команда print]]
[[#2. Ввод данных, команда input(), переменные]]
[[#3. Переменные]]
[[#4. Параметры sep и end]]
[[#5. Множественное присваивание]]
[[#6. PEP8]]
[[#7. Целочисленная арифметика. Часть 1]]
[[#8. Целочисленная арифметика. Часть 2]]

#### 1. Вывод данных, команда print

```python
print()   /   Для вывода данных на экран
```

==Запомни:== кавычки могут быть или одинарными, или двойными. Следующие две строки делают одно и то же:

==Аргумент:== – это конкретные значения, которые вы передаете функции при ее вызове.

==Запомни:== при написании кода между аргументами команды `print()` после запятой мы ставим один символ пробел. Это общепринятое соглашение в языке Python. Этот символ пробела не влияет на вывод данных. Это просто **для читабельности кода**.


#Примечания 

<font color="#de7802">Примечание 1.</font> Команда `print()` записывается только маленькими буквами, другое написание недопустимо, так как в Python строчные и заглавные буквы [различны](https://ru.wikipedia.org/wiki/%D0%A7%D1%83%D0%B2%D1%81%D1%82%D0%B2%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%BA_%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D1%83_%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2).

<font color="#de7802">Примечание 2.</font> Каждая последующая команда `print()` выводит указанный текст **с новой строки**.

<font color="#de7802">Примечание 3.</font> Команда `print()` с пустым списком аргументов просто вставляет новую пустую строку.

<font color="#de7802">Примечание 4.</font> Почему в Python можно использовать как одинарные, так и двойные кавычки для обрамления текста? Ответ очень прост — часто кавычки являются частью текста. И чтобы Python мог правильно распознать такой текст, пользуемся разными:

<font color="#de7802">Примечание 5.</font> Обратите внимание, что в одном `print()` мы можем комбинировать одинарные и двойные кавычки. Это делает наш код более гибким, позволяя легко включать кавычки и апострофы в наши строки.

<font color="#de7802">Примечание 6.</font> Мы не можем использовать одинарные кавычки в строке, если саму строку обрамляем одинарными кавычками. С двойными кавычками ситуация аналогичная.

#### 2. Ввод данных, команда input()

```python
print('Как тебя зовут?')   /  вывод текста print('Привет,', input())  /  ввод текста и вывод текста
```

Вот пример на программе VS Code 
Все показано на картинке стрелками 
![[Screenshot 2024-08-21 092200.png]]
В VS Code после введения текста нужно нажать клавишу **Enter**:
![[Screenshot 2024-08-21 092337.png]]
После нажатия клавиши **Enter** у нас был выведен текст `'Привет, Сэм'`, и программа завершила свою работу.

#### 3. Переменные

```python
variable_name = input() 
print('Вы ввели текст:', variable_name)
```
Данный код означает: "Сохрани то, что ввел пользователь, в памяти, и дальше это место в памяти мы будем называть именем `variable_name`". Соответственно, команда `print(variable_name)` означает: "Посмотри, что лежит в памяти под именем `variable_name`, и выведи это на экран".

<font color="#00b0f0">Вот такие "места в памяти" и называются переменными. Любая переменная имеет имя и значение.</font>

==Имя переменной:==

1. В имени переменной рекомендуется использовать только латинские буквы `a-z`, `A-Z`, цифры и символ нижнего подчеркивания (`_`)
2. Имя переменной не может начинаться с цифры
3. Имя переменной не может содержать пробелы
4. Имя переменной по возможности должно отражать ее назначение

<font color="#00b0f0">Запомни:</font> Python — регистрочувствительный язык. Переменная `name` и `Name` — две совершенно разные переменные.

==Значение переменной:==

<font color="#00b0f0">Значение переменной</font> — это сохраненная в ней информация: текст, число и т.д.
Символ `=` в языках программирования выступает в роли оператора присваивания.
![[Screenshot 2024-08-21 094016.png]]

<font color="#00b0f0">Запомни:</font> интерпретатор ждет, что пользователь что-то введет с клавиатуры ровно столько раз, сколько команд `input()` встречается в программе. Каждый `input()` завершается нажатием **Enter** на клавиатуре.

#Примечания
Примечание 1. Очень часто перед считыванием данных мы печатаем некоторый текст, чтобы пользователь, который вводит эти данные, понимал, что именно от него требуется. Например, в программе:
```python
# сначала тут печатается строка 'Как тебя зовут', а потом принимается на вход имя 
name = input('Как тебя зовут?')
```

Примечание 2. Имейте в виду, что мы можем принимать сразу несколько строк, а потом со всеми ними работать.

Примечание 3. Переменные можно вводить в любой момент (не только в самом начале программы):
```python
name_1 = input()                 /  принимаем имя первого человека 
print('Привет, ', name_1, '!')   /   делаем первый вывод 
name_2 = input()                 /   принимаем имя второго человека 
print('Здравствуйте, ', name_2, '.')   /   делаем второй вывод
```

- Имя переменной может содержать буквы, цифры и символ нижнего подчеркивания ( _ )
- Имя переменной не может начинаться с цифры
- Имя переменной не может содержать пробелы

#### 4. Параметры sep и end 

==Тема урока: sep, end, переменные, PEP 8==

1. Необязательные параметры команды `print()`: `sep`, `end`
2. Множественное присваивание
3. Стандарт PEP 8
4. Комментарии

<font color="#00b0f0">1.Необязательные параметры команды print</font>
==Параметр sep==

```python
print('aa', 'bb', 'cc')
aa bb cc   /    Результатом выполнения такого кода будет
```

А теперь начнем использовать `sep`
```python
print('aa', 'bb', 'cc', sep=' ')
```
Мы можем изменить параметр `sep`  в то что мы хотим:
```python
print('aa', 'bb', 'cc', sep='*')
# выводит:
aa*bb*cc
```

Таким образом, необязательный параметр `sep` команды `print()` позволяет установить строку, с помощью которой будут разделены аргументы (если их несколько) при печати.

==Параметр end==
После команды `print` курсор переходит на новую строку. У команды `print` есть параметр `end`. По умолчанию параметр `end` равен символу перевода строки (`\n`).

Следующие строки кода являются эквивалентными:
```python
print("A great man doesn't seek to lead.")
print("He's called to it. And he answers.")

print("A great man doesn't seek to lead.", end='\n')
print("He's called to it. And he answers.", end='\n')
```

А если изменить параметр `end`
```python
minus = '-'
print('a', 'b', 'c', end=minus)
print('second line')

# то он выведит
a b c-second line
```

Таким образом, параметр `end` определяет строку, которая будет добавлена после вывода всех аргументов команды `print()`.

#примечание

<font color="#00b0f0">Примечание 1</font>. Вызов команды `print()` с пустыми скобками делает перевод строки.

<font color="#00b0f0">Примечание 2.</font> Последовательность символов `\n` называется **управляющей последовательностью** и задаёт перевод строки.

<font color="#00b0f0">Примечание 3.</font> Параметры `sep` и `end` можно устанавливать одновременно.

<font color="#00b0f0">Примечание 4.</font> Для разных команд `print()` можно задавать разные параметры `sep` и `end`.

<font color="#00b0f0">Примечание 5.</font> Чтобы убрать все дополнительные выводимые символы, можно установить параметры `sep` и `end` команды `print()` как пустые строки (`''`).

<font color="#00b0f0">Примечание 6.</font> Если после вывода данных нужно более одного перевода строки, то можно использовать следующий код:
```python
print('Python', end='\n\n\n')
```

<font color="#00b0f0">Примечание 7.</font> Мы не можем указывать параметры `sep` и `end` перед аргументами, так как именованные параметры всегда должны следовать после позиционных аргументов. Подробнее эту тему мы разбираем в курсе для продвинутых, сейчас же рекомендуем вам просто запомнить.

<font color="#00b0f0">Примечание 8.</font> Параметр `sep` является разделителем для нескольких аргументов в команде `print()`.

#### 5. Множественное присваивание

Вот пример:
```python
 name, surname = 'Timur', 'Guev'
 print('Имя:', name, 'Фамилия:', surname)
```
Этот код можно записать и так:
```python
name = 'Timur'
surname = 'Guev'
print('Имя:', name, 'Фамилия:', surname)
```

Если требуется считать текст с клавиатуры и присвоить его в качестве значения переменным, то можно написать так:
```python
name, surname = input(), input()
print('Имя:', name, 'Фамилия:', surname)
```

#примечание 

<font color="#00b0f0">Примечание 1.</font> Названия переменных ничего не говорят интерпретатору о значениях в этих переменных, и даже в очень хорошо названной переменной не появится нужное значение, если мы сами его туда не запишем.

<font color="#00b0f0">Примечание 2.</font> Новое значение переменной вытесняет старое. Важно представлять, чему равно значение переменной в каждый момент времени.

<font color="#00b0f0">Примечание 3.</font> В качестве названия переменных запрещено использовать ключевые (зарезервированные) слова. К ключевым словам в языке Python относятся:

| False | and      | def     | import   | pass   |
| ----- | -------- | ------- | -------- | ------ |
| True  | with     | del     | in       | raise  |
| None  | as       | elif    | is       | return |
| break | assert   | else    | lambda   | while  |
| class | continue | except  | nonlocal | yield  |
| try   | from     | finally | not      |        |
| for   | global   | if      | or       |        |

#### 6. PEP8

При оформлении программ мы будем пользоваться **PEP 8 — Python Enhancement Proposal**. Этот документ предлагает единый и общепринятый стиль написания программ на языке Python. Документ создан по рекомендациям Гвидо Ван Россума, автора Python. Прочесть его на русском языке можно по [ссылке](https://pythonworld.ru/osnovy/pep-8-rukovodstvo-po-napisaniyu-koda-na-python.html).

==Некоторые рекомендации PEP 8==
<font color="#e36c09">Рекомендация 1.</font> Избегайте использования пробелов перед открывающей скобкой, после которой начинается список аргументов функции.

<font color="#e36c09">Рекомендация 2.</font> После запятой нужен пробел.

<font color="#e36c09">Рекомендация 3.</font> Не отделяйте пробелами знак «равно», когда он употребляется для обозначения значения параметра по умолчанию.

#примечание 
<font color="#00b0f0">Примечание 1.</font> Согласно стандарту PEP 8, комментарии должны отделяться хотя бы двумя пробелами от кода. Они должны начинаться с символа # и одного пробела.

<font color="#00b0f0">Примечание 2.</font> При вводе комментариев в среде Wing IDE вы обнаружите, что они выделяются цветом. Это сделано, чтобы облегчить чтение кода.


#### 7. Целочисленная арифметика. Часть 1

1. Целочисленный тип данных
2. Преобразование строки к целому числу
3. Операции над целыми числами
4. Частые ошибки
5. Решение задач

==Целые числа==
```python
num1 = 7 # num1 - это число
num2 = 10 # num2 - это число
num3 = num1 + num2 # num3 - это число

print(num3)
```
<font color="#00b0f0">Запомни:</font> числа обозначаются без кавычек, а строки — с кавычками.

==Основные операции с числами==
В языке Python, как и в математике, над числами можно совершать 4 основные операции (`+`, `-`, `*`, `/`).
```python
a = 3 
b = 2

print(a + b) 
print(a - b) 
print(a * b) 
print(a / b)

# выводит:
5 
1 
6 
1.5
```

==Порядок выполнения операций==
```python
num1 = 2 + 3 * 4
num2 = (2 + 3) * 4

print(num1)
print(num2)

# выводит:
14 
20
```
**Запомни:** первым делом выполняется умножение или деление, затем сложение и вычитание. Для изменения порядка выполнения операций понадобятся скобки.

==Преобразование типов==

<font color="#00b0f0">1. Преобразование строки к целому числу</font>
Для того чтобы преобразовать строку к целому числу, мы используем команду `int()`.
```python
s = '1992'
year = int(s)
print(year)
```

**Запомни:** для того чтобы считать одно целое число, мы пишем следующий код:
```python
num = int(input())
```

<font color="#00b0f0">2.  Преобразование целого числа к строке</font>
Для того чтобы преобразовать целое число в строку, мы используем команду `str()`. Рассмотрим следующий код:
```python
num = 17
s = str(num) # теперь s содержит строку '17'
```
Переменная `num` имеет целый тип данных. С помощью команды `str()` мы преобразовали целое число в строку и записали результат в переменную `s`. Таким образом, переменная `num` имеет целочисленный тип данных, а переменная `s` – строковый тип данных.

#примечание 
<font color="#00b0f0">Примечание 1.</font> При работе с целочисленными переменными часто нужно осуществлять присвоение значению переменной целой математической формулы:
```python
<имя переменной> = <математическая формула>
```
![[Screenshot 2024-08-21 151156.png]]

<font color="#00b0f0">Примечание 2.</font> Сокращение `int` происходит от английского **integer** – целый.

<font color="#00b0f0">Примечание 3.</font> В большинстве языков программирования переменная [целого типа](https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BB%D0%BE%D0%B5_(%D1%82%D0%B8%D0%BF_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)) имеет ограничения. Например, в языке C# переменная целого типа может принимать значения из диапазона [−263;263−1][−263;263−1]. В Python реализована так называемая **длинная арифметика,** то есть, по сути, переменная целого типа не имеет ограничений.

<font color="#00b0f0">Примечание 4.</font> Минус может использоваться для обозначения отрицательных чисел. А вот операции `+`, `/` и `*` всегда стоят между двумя переменными и что-то с ними делают.
```python
num1 = -6 # унарный минус
num2 = 17 - 7 # бинарный минус
```


#### 8. Целочисленная арифметика. Часть 2

1. Операция возведения в степень (`**`)
2. Операция нахождения остатка (`%`)
3. Операция целочисленного деления (`//`)
4. Обработка цифр числа
5. Частые ошибки
6. Решение задач

==Дополнительные операции==

| Оператор | Описание              |
| -------- | --------------------- |
| **       | Возведение в степень  |
| %        | Остаток от деления    |
| //       | Целочисленное деление |
<font color="#00b0f0">Запомни:</font> в отличие от многих языков программирования, в языке Python для возведения в степень используется оператор `**`, а не `^`.

<font color="#00b0f0">Обратите внимание:</font> оператор возведения в степень (`**`) является правоассоциативным (значение выражения вычисляется справа налево) в соответствии с правилами математики. Таким образом, выражение `x ** y ** z` вычисляется как `x ** (y ** z)`.

==Целочисленное деление==
Для положительных чисел оператор целочисленного деления (`//`) ведёт себя как обычное деление, за исключением того, что он отбрасывает десятичную часть результата.

Приведённый ниже код:
```python
print(10 // 3) 
print(10 // 4) 
print(10 // 5) 
print(10 // 6) 
print(10 // 12)

# выводит:
3 
2 
2 
1 
0
```

```python
print(10 // 3) 
print(-10 // 3)

#выводит:
3 # округление в меньшую сторону 
-4 # округление в меньшую сторону
```

==Деление с остатком==
Оператор деления с остатком (`%`) возвращает остаток от деления двух целых чисел. Рассмотрим работу данного оператора на примерах.
```python
print(10 % 3) 
print(10 % 4) 
print(10 % 5) 
print(10 % 6) 
print(10 % 12) 
print(10 % 20)

# выводит:
1 
2 
0 
4 
10 
10
```

<font color="#00b0f0">Запомни:</font> при нахождении остатка от деления на целое число nn может получаться результат 0,1,2,…n −10,1,2,…n −1. Например, при делении на 22 возможны остатки 0,10,1, при делении на 33 возможны остатки 0,1,20,1,2 и т.д.

#примечание 
<font color="#00b0f0">Примечание 1.</font> Оператор нахождения остатка очень полезен при решении многих задач. Например, число делится на nn нацело тогда и только тогда, когда остаток от деления на nn равен 00.

<font color="#00b0f0">Примечание 2.</font> Таблица приоритетов арифметических операторов в Python приведена ниже (чем ниже расположен оператор в таблице, тем ниже его приоритет).

| Оператор          | Описание                                                      |
| ----------------- | ------------------------------------------------------------- |
| ()                | Скобки                                                        |
| **                | Возведение в степень                                          |
| - (унарный минус) | Унарный минус                                                 |
| *,  /,  //,  %    | Умножение, деление, целочисленное деление, остаток от деления |
| +,  -             | Сложение, вычитание                                           |

<font color="#00b0f0">Примечание 3.</font> Полезно прочитать про [модулярную арифметику](https://ru.wikipedia.org/wiki/%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE_%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8E) в математике.

<font color="#00b0f0">Примечание 4.</font> Обратите внимание: при `n < m` результатом деления `n % m` является число `n`, а результатом деления `n // m` является число `0`.


==Обработка  цифр числа==

<font color="#00b0f0">Запомни:</font> последняя цифра числа определяется всегда как **остаток от деления** числа на `10 (% 10)`. Чтобы отщепить последнюю цифру от числа, необходимо разделить его **нацело** на `10 (// 10)`.

==Алгоритм получение цифр n-значения числа==

Несложно понять, по какому алгоритму можно найти каждую цифру nn-значного числа `num`:
- Последняя цифра: `(num % 101) // 100`;
- Предпоследняя цифра: `(num % 102) // 101`;
- Предпредпоследняя цифра: `(num % 103) // 102`;
- .....
- Вторая цифра: `(num % 10n-1) // 10n-2`;
- Первая цифра: `(num % 10n) // 10n-1`.

<font color="#00b0f0">Рассмотрим программу получения цифр трёхзначного числа:</font>
```python
num = 754 
a = num % 10 
b = (num % 100) // 10 
c = num // 100 
print(a) 
print(b) 
print(c)
```

## Условный оператор

[[#1. Выбор из двух]]
[[#2. Логические операции]]
[[#3. Вложенные и каскадные условия]]

#### 1. Выбор из двух

==Условный оператор if-else==
<font color="#00b0f0">Аннотация.</font> Урок посвящен условному оператору `if-else`.

<font color="#92d050">Проверка условий и принятие решений по результатам этой проверки называется ветвлением (branching). Программа таким способом выбирает, по какой из возможных ветвей ей двигаться дальше.</font>

Блоком кода называют объединенные друг с другом строки. Они всегда связаны с определенной частью программы (например, с инструкцией `if`). В Python блоки кода формируются при помощи **отступов**.
![[Screenshot 2024-08-22 121807.png]]

Если условие оказалось ложным:
![[Screenshot 2024-08-22 122216.png]]

==Отступы==
<font color="#00b0f0">Отступ</font> — небольшое смещение строки кода вправо. В начале такой строки находятся пробелы, и поэтому она на несколько символов отстоит от левого края.

По соглашению PEP 8, для отступа блоков кода используются **4 пробела**. Если в среде VS Code или Wing IDE нажать на клавишу Enter после `if`, она автоматически выставит **4 пробела**.

==Операторы сравнения==
Оператор присваивания (`=`) присваивает переменным значения:
```python
num = 1992 
s = 'I love Python'
```

Для проверки двух элементов на равенство Python использует удвоенный знак равно (`==`). Вот так:
```python
if answer == 'Python': 
... 
if name == 'Gvido': 
... 
if temperature == 40: 
...
```

В Python существует 6 основных операторов сравнения.

| Выражение | Описание                    |
| --------- | --------------------------- |
| if x > 7  | если x больше 7             |
| if x < 7  | если x меньше 7             |
| if x >= 7 | если x больше либо равен  7 |
| if x <= 7 | если x меньше либо равен  7 |
| if x == 7 | если x равен  7             |
| if x != 7 | если x не равен  7          |

==Цепочки сравнений==
```python
age = int(input()) 
if 3 <= age <= 6: 
print('Вы ребёнок')
```

Так же для трех переменных:
```python
if a == b == c: 
print('числа равны') 
else: 
print('числа не равны')
```

==Транзитивность==
Операция неравенства (`!=`), в отличие от операции равенства (`==`), является [нетранзитивной](https://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D1%81%D1%82%D1%8C). То есть из того, что `a != b` и `b != c` вовсе не следует, что `a != c`. Действительно, если вас зовут не так, как соседа слева и не так, как соседа справа, то нет гарантии, что у обоих соседей не окажутся одинаковые имена.

```python
if a != b != c: 
print('числа не равны') 
else: 
print('числа равны')
```




#### 2. Логические операции 

==Логические операторы==
В Python есть три логических оператора, которые позволяют создавать сложные условия:
- `and` — логическое умножение;
- `or` — логическое сложение;
- `not` — логическое отрицание.

==Оператор and==
```python
age = int(input('Сколько вам лет?: ')) 
grade = int(input('В каком классе вы учитесь?: ')) 
if age >= 12 and grade >= 7: 
print('Доступ разрешен.') 
else: 
print('Доступ запрещен.')
```

Оператор `and` может объединять произвольное количество условий:
```python
age = int(input('Сколько вам лет?: ')) 
grade = int(input('В каком классе вы учитесь?: ')) 
city = input('В каком городе вы живете?: ') if age >= 12 and grade >= 7 and city == 'Москва': 
print('Доступ разрешен.') 
else: 
print('Доступ запрещен.')
```

Вот все возможные комбинации истинности и ложности:

| a     | b     | a and b |
| ----- | ----- | ------- |
| False | False | False   |
| False | True  | False   |
| True  | False | False   |
| True  | True  | True    |

==Оператор or==
Оператор `or` также применяется для объединения условий. Однако, в отличие от `and`, для выполнения блока кода достаточно выполнения **хотя бы одного из условий**.
```python
city = input('В каком городе вы живете?: ') if city == 'Москва' or city == 'Санкт-Петербург' or city == 'Екатеринбург': print('Доступ разрешен.') 
else: 
print('Доступ запрещен.')
```

Так же вот таблица:

| a     | b     | a or b |
| ----- | ----- | ------ |
| False | False | False  |
| False | True  | True   |
| True  | False | True   |
| True  | True  | True   |
<font color="#00b0f0">Логическое выражение `X and Y` истинно, если оба значения X и Y истинны.</font>

<font color="#00b0f0">Логическое выражение `X or Y` истинно, если хотя бы одно из значений X и Y истинно.</font>

Можно так же использовать и `or` и `and`

==Оператор not==
Просто делает код противоположным
Вот таблица:

| a     | not a |
| ----- | ----- |
| False | True  |
| True  | False |

==Приоритеты логических операторов==

Логические операторы, подобно арифметическим операторам (`+`, `-`, `*`, `/`), имеют приоритет выполнения. Приоритет выполнения следующий:

- в первую очередь выполняется логическое отрицание `not`;
- далее выполняется логическое умножение `and`;
- далее выполняется логическое сложение `or`.

#Примечания 
<font color="#00b0f0">Примечание 1.</font> Не забывайте, что в Python есть удобный способ для проверки принадлежности диапазону. Например, следующий код:
```python
if age >= 7 and age <= 9:
```

<font color="#00b0f0">Примечание 2.</font> Оба оператора, `and` и `or`, вычисляются по **укороченной схеме**.
Вот как это работает с оператором `and`. Если условие слева от оператора `and` является ложным, то условие справа от него не проверяется, так как результат выражения будет гарантированно ложным и проверка оставшегося условия — пустая трата процессорного времени.





#### 3. Вложенные и каскадные условия 

==Вложенный оператор==
Вот пример:
```python
grade = int(input('Введите вашу отметку по 100-балльной системе: ')) 
if grade >= 90: 
    print(5) 
else: 
    if grade >= 80: 
        print(4) 
    else: 
        if grade >= 70: 
            print(3) 
        else: 
            if grade >= 60: 
                print(2) 
            else: 
                print(1)
```
Выбор из нескольких альтернатив – это обычное дело, здесь имеет смысл избегать глубокого вложения. Для этого в Python есть **каскадный условный оператор**.

==Каскадный условный оператор==
Синтаксис каскадного условного оператора имеет следующий вид:
![[Screenshot 2024-08-23 112943.png]]

Т.е можно записать в другом виде:
```python
grade = int(input('Введите вашу отметку: ')) if grade >= 90: 
    print(5) 
elif grade >= 80: 
    print(4) 
elif grade >= 70: 
    print(3) 
elif grade >= 60: 
    print(2) 
else: 
    print(1)
```

<font color="#00b0f0">Запомни.</font> Заключительный блок `else` в операторе `if-elif-else` является необязательным:
```python
traffic_light_signal = input('Введите сигнал светофора: ') 
if traffic_light_signal == 'красный':             print('Стой!') 
elif traffic_light_signal == 'желтый':            print('Приготовься...') 
elif traffic_light_signal == 'зеленый':           print('Иди!')
```

## Типы данных

[[#1. Числовые типы данных int, float]]
[[#2. Строковой тип данных]]
[[#3. Модуль math]]

#### 1. Числовые типы данных: int, float

==Преобразование строки в целое число==
Для преобразования строки в целое число, мы используем команду `int()`:
```python
num = int(input()) # преобразование считанной строки в целое число
```
Для преобразования строки в целое число не обязательно использовать команду `input()`.

Следующий код преобразует строку `12345` в целое число:
```python
n = int('12345') # преобразование строки в целое число
```
Если строка не является числом, то при преобразовании возникнет ошибка.

==Целочисленные операторы==
Следующая программа демонстрирует все целочисленные операторы:
```python
a = 13 
b = 7 
total = a + b 
diff = a - b 
prod = a * b 
div1 = a / b 
div2 = a // b 
mod = a % b 
exp = a ** b 
print(a, '+', b, '=', total) 
print(a, '-', b, '=', diff) 
print(a, '*', b, '=', prod) 
print(a, '/', b, '=', div1) 
print(a, '//', b, '=', div2) 
print(a, '%', b, '=', mod) 
print(a, '**', b, '=', exp)
```
В результате работы такой программы будет выведено:
```python
13 + 7 = 20 
13 - 7 = 6 
13 * 7 = 91 
13 / 7 = 1.8571428571428572 
13 // 7 = 1 
13 % 7 = 6 
13 ** 7 = 62748517
```
При обычном делении (/) получается число не являющееся целым. Деление на ноль приводит к ошибке.

==Символ разделитель==
Для удобного чтения чисел можно использовать символ подчеркивания:
```python
num1 = 25_000_000 
num2 = 25000000 
print(num1) 
print(num2)
```

==Числа с плавающей точкой==

Дробные (вещественные) числа в информатике называют **числами с плавающей точкой**.

Для представления чисел с плавающей точкой в Python используется тип данных `float`.
```python
e = 2.71828 # литерал с плавающей точкой 
pi = 3.1415 # литерал с плавающей точкой
```

==Преобразование строки к числу с плавающей точкой==
Для преобразования строки к числу с плавающей точкой мы используем команду `float()`:
```python
num = float(input()) # преобразование считанной строки в число с плавающей точкой
```

Для преобразования строки к числу с плавающей точкой необязательно использовать команду `input()`.
```python
n = float('1.2345') # преобразование строки к числу с плавающей точкой
```
<font color="#00b0f0">Если строка не является числом, то при преобразовании возникнет ошибка.</font>

==Преобразование между int и float==
<font color="#00b0f0">Неявное преобразование.</font> Любое целое число (тип `int`) можно использовать там, где ожидается число с плавающей точкой (тип `float`), поскольку при необходимости Python автоматически преобразует целые числа в числа с плавающей точкой.

<font color="#00b0f0">Явное преобразование.</font> Число с плавающей точкой нельзя неявно преобразовать в целое число. Для такого преобразования необходимо использовать явное преобразование с помощью команды `int()`.
```python
num1 = 17.89 
num2 = -13.56 
num3 = int(num1) 
num4 = int(num2) 
print(num3) 
print(num4)

# Результатом выполнения такого кода будет:
17 
-13
```
<font color="#00b0f0">Не путайте операцию преобразования и округления. Для округления чисел с плавающей точкой используются дополнительные команды. О них расскажем позже.</font>

==Встроенные функции==
- `print()` — вывести на экран;
- `input()` — считать с клавиатуры;
- `int()` — преобразовать к целому числу;
- `float()` — преобразовать к числу с плавающей точкой.

==Функции min() и max()==
```python
a = max(3, 8, -3, 12, 9) 
b = min(3, 8, -3, 12, 9) 
c = max(3.14, 2.17, 9.8) 
print(a) 
print(b) 
print(c)

# будет:
12 
-3 
9.8
```

==Функция abs()==
![[Screenshot 2024-08-24 081255.png]]

Для нахождения модуля (абсолютной величины) числа в Python используется функция `abs()`.
```python
print(abs(10)) 
print(abs(-7)) 
print(abs(0)) 
print(abs(-17.67))

# будет:
10 
7 
0 
17.67
```
<font color="#00b0f0">Обратите внимание, все три функции max(), min(), abs() работают как с целыми числами, так и с числами с плавающей точкой.</font>




#### 2. Строковой тип данных

==Строковый тип данных и Длина строки==

Длиной строки называется количество символов из которых она состоит. Чтобы посчитать длину строки используем встроенную функцию `len()` (от слова length – длина).
```python
s1 = 'abcdef' 
length1 = len(s1) # считаем длину строки из переменной s1 
length2 = len('Python rocks!') # считаем длину строкового литерала 
print(length1) 
print(length2)

# выведет:
6 
13
```
<font color="#00b0f0">При подсчете длины строки считаются все символы, включая пробелы.</font>

==Преобразование чисел в строку==

Для преобразования строки к числу мы использовали функции `int()` и `float()`. Для обратного преобразования, то есть из числа в строку мы используем функцию `str()`:
```python
num1 = 1777 # целое число 
num2 = 17.77 # число с плавающей точкой 
s1 = str(num1) # преобразовали целое число в строку '1777' 
s2 = str(num2) # преобразовали число с плавающей точкой в строку '17.77'
```
<font color="#00b0f0">Иногда работать со строками намного проще, чем с числами. Даже если в условии задачи сказано, что дается число, нам ничто не мешает работать с ним как со строкой.</font>

==Конкатенация строк==

Строки, как и числа, можно складывать. Операция сложения строк называется **конкатенацией** или **сцеплением**.
```python
s1 = 'ab' + 'bc' 
s2 = 'bc' + 'ab' 
s3 = s1 + s2 + '!!' 
print(s1) 
print(s2) 
print(s3)

# Результатом выполнения такого кода будет:
abbc 
bcab 
abbcbcab!!
```

==Умножение строки на число==
```python
s = 'Hi' * 4 
print(s)

# Результатом выполнения такого кода будет:
HiHiHiHi
```

Можно вот к примеру так использовать:
```python
print('-' * 75)

# Результатом выполнения такого кода будет:
---------------------------------------------------------------------------
```
<font color="#00b0f0">Строку можно умножать на число, но нельзя умножать на строку.</font>

#Примечания
Тройные кавычки в Python используются для многострочного (multiline) текста. 
```python
text = '''Python is an interpreted, high-level, general-purpose programming language. Created by Guido van Rossum and first released in 1991, Python design philosophy emphasizes code readability with its notable use of significant whitespace.'''
```

==Оператор in==

В Python есть специальный оператор `in`, который позволяет проверить, что одна строка находится внутри другой.
```python
s = 'https://pygen.ru/' 
if 'a' in s: 
    print('Введенная строка содержит символ а') else: 
    print('Введенная строка не содержит символ а')

# проверяет, содержится ли в переменной `s` символ `'a'`, и выводит:
Введенная строка не содержит символ а
```

==Использование вместе с логическими операторами==

Мы можем использовать оператор `in` вместе с логическим оператором `not`, например:
```python
s = input() 
if '.' not in s: 
print('Введенная строка не содержит символа точки')
```

С помощью оператора `in` мы можем упростить следующий код, проверяющий, что значение переменная `s` равно одному из пяти символов `'a'`, `'e'`, `'i'`, `'o'`, `'u'`:
```python
if s == 'a' or s == 'e' or s == 'i' or s == 'o' or s == 'u': 
    print('YES')

# до вида:
if len(s) == 1 and s in 'aeiou': 
    print('YES')
```

<font color="#00b0f0">Примечание.</font> Если строка `s1` содержится в строке `s2`, то говорят, что строка `s1` является **подстрокой** для строки `s2`. Другими словами, оператор `in` определяет, является ли одна строка подстрокой для другой строки.



#### 3. Модуль math

==Модуль math==

Модуль `math` – один из наиважнейших в Python. Этот модуль предоставляет обширный функционал для проведения вычислений с действительными числами (числами с плавающей точкой).
```python
import math 
num1 = math.sqrt(2) # вычисление квадратного корня из двух 
num2 = math.ceil(3.8) # округление числа вверх 
num3 = math.floor(3.8) # округление числа вниз 

print(num1) 
print(num2) 
print(num3)

# и выводит:
1.4142135623730951 
4 
3
```

==Особенности подключения модулей==

Для того что бы мудуль постоянно работал мы после `math` пишем `.` . Для того что бы постоянно не писать это:
```python
from math import * 

num1 = sqrt(2) # вычисление корня квадратного из двух 
num2 = ceil(3.8) # округление числа вверх 
num3 = floor(3.8) # округление числа вниз 
print(num1) 
print(num2) 
print(num3)
```

Если нужно использовать только некоторые функции модуля, то мы можем импортировать только их следующим образом:
```python
from math import sqrt, ceil
```

==Список функций модуля math==
![[Screenshot 2024-08-24 101627.png]]

![[Screenshot 2024-08-24 101645.png]]

![[Screenshot 2024-08-24 101705.png]]
Для извлечения квадратного корня можно воспользоваться кодом `n ** 0.5`, вместо `math.sqrt(n)`.

==Список констант модуля math==
![[Screenshot 2024-08-24 101829.png]]

<font color="#00b0f0">Примечание 1.</font> Все функции модуля `math` возвращают значение, которое можно вывести на экран, присвоить другой переменной или использовать в математическом выражении.

<font color="#00b0f0">Примечание 2.</font> Для использования функций `int()`, `float()`, `abs()`, `min()`, `max()`, `round()` подключать модуль `math` нет необходимости. Это так называемые встроенные функции.


## Циклы for и while

[[#1. Цикл for]]
[[#2. Цикл for функция range]]
[[#3. Частые сценарии]]
[[#4. Цикл while]]
[[#5. Цикл while обработка цифр числа]]
[[#6. break, continue и else]]
[[#7. Поис ошибок и ревью кода]]
[[#8. Вложенные циклы. Часть 1]]
[[#9. Вложенные циклы. Часть 2]]

#### 1. Цикл for

==Цикл for==
В Python существует две основных разновидности циклов:
- циклы, повторяющиеся определенное количество раз (`for`, счетные циклы, **counting loops**);
- циклы, повторяющиеся до наступления определенного события (`while`, условные циклы, **conditional loops**).

Структура цикла `for` в Python выглядит так:
```python
for название_переменной_цикла in range(количество_повторений): 
блок кода
```
 Блок команд, который выполняется в цикле `for`, называется телом цикла.

Рассмотрим следующий программный код:
```python
for i in range(5): 
    num = int(input()) 
    print("Квадрат вашего числа равен:", num * num) 
print("Цикл завершен")
```

#Примечания
<font color="#00b0f0">Примечание 1.</font> Однократное выполнение тела цикла называется **итерацией цикла**.

<font color="#00b0f0">Примечание 2.</font> Графическое представление цикла `for` имеет вид:
![[Screenshot 2024-08-26 084914.png]]

==Переменная цикла==

Когда цикл впервые начинает работу, Python устанавливает значение переменной цикла `i = 0`. Каждый раз, когда мы повторяем тело цикла, Python увеличивает значение переменной на 11.

Рассмотрим следующий код:
```python
for i in range(10): 
    print(i, '-- Привет')

# Результатом выполнения такого кода будет:

0 -- Привет
1 -- Привет
2 -- Привет
3 -- Привет
4 -- Привет
5 -- Привет
6 -- Привет
7 -- Привет
8 -- Привет
9 -- Привет
```


==Имена переменных цикла==
Следующие две программы абсолютно одинаковые: в первой программе переменная цикла имеет название `i`, во второй программе – `number`:
```python
for i in range(10): 
    print(i)
for number in range(10):
    print(number)
```
<font color="#00b0f0"> Если переменная цикла не используется в теле цикла, то указывать вместо неё можно что угодно</font>



#### 2. Цикл for: функция range

==Перегрузка range() с двумя параметрами==
Напишем программу, которая выводит те числа из промежутка [100;999][100;999], которые оканчиваются на 7.
```python
for i in range(100, 1000): # перебираем числа от 100 до 999 
    if i % 10 == 7: # используем остаток от деления на 10, для получения последней цифры 
        print(i)
```

Если первый параметр больше второго, то функция `range()` генерирует пустую последовательность. Например, вызов функции `range(10, 1)` приводит к генерации пустой последовательности.

==Перегрузка range() с 3 параметрами==
Используя функцию `range()` с тремя параметрами, получаем:
```python
for i in range(56, 171, 2): 
    print(i)
```
Обратите внимание, мы можем использовать функцию `range()` с двумя параметрами:
```python
for i in range(56, 171): 
    if i % 2 == 0: 
        print(i)
```

==Отрицательный шаг генерации==
Напишем программу, которая отсчитывает от 5 до 1, а затем выводит текст `Взлетаем!!!`:
```python
for i in range(5, 0, -1): 
    print(i, end=' ') 
print('Взлетаем!!!')
```
Если величина шага отрицательна и первый параметр меньше второго, то функция `range()` генерирует пустую последовательность. Например, вызов функции `range(1, 10, -1)` приводит к генерации пустой последовательности.

#примечание 
<font color="#00b0f0">Примечание 1.</font> Функция `range()` может принимать от одного до трех параметров: `range(n), range(n, m), range(n, m, k)`

- первый параметр – это старт последовательности (включительно);
- второй параметр – это стоп последовательности (не включительно);
- третий параметр – это величина шага.

<font color="#00b0f0">Примечание 2.</font> Функция `range()` может генерировать только целые числа, включая отрицательные.



#### 3. Частые сценарии

==Подсчет количества==
<font color="#00b0f0">Подсчет количества</font> – это очень частый сценарий. Он состоит из двух шагов:

1. Создание **переменной счетчика**, и придание ей первоначального значения: `counter = 0`;
2. Увеличение переменной счетчика на 11: `counter = counter + 1`.

Модифицируем предыдущую программу: посчитаем еще и количество нулей среди введенных чисел.
```python
counter1 = 0 
counter2 = 0 
for _ in range(10): 
    num = int(input()) 
    if num > 10: 
        counter1 = counter1 + 1 
    if num == 0: 
        counter2 = counter2 + 1 

print('Было введено', counter1, 'чисел, больших 10.') 
print('Было введено', counter2, 'нулей.' )
```
Для переменной счетчика удобно использовать имя `counter` (или более сокращенно `cnt`).

==Вычисление суммы и произведения==
**Подсчет суммы** состоит из двух шагов:

1. Создание переменной **сумматора** и придание ей первоначального значения: `total = 0`;
2. Увеличение переменной сумматора на нужное число: `total = total + num`.

Напишем программу, которая считает сумму натуральных чисел от 11 до 100100:
```python
total = 0 
for i in range(1, 101): 
    total = total + i 
print('Сумма равна', total)
```

Рассмотрим еще один пример: напишем программу, которая запрашивает 1010 целых чисел и находит их среднее значение:
```python
total = 0 
for _ in range(10): 
    num = int(input()) 
    total = total + num 
average = total / 10 
print('Среднее значение равно', average)
```
Аналогичным образом вычисляется произведение. При вычислении произведения начальное значение переменной **мультипликатора** мы устанавливаем равным 11, в отличие от сумматора, где оно равно 00.

Для переменной сумматора и мультипликатора удобно использовать имя `total`.

==Обмен значений переменных==
Вот пример как поменять значения местами:
```python
temp = x 
x = y 
y = temp
```
Такой код пишут почти во всех языках программирования. Однако в Python есть и более простой способ. Мы можем написать так:
```python
x, y = y, x
```
В результате выполнения такого кода Python поменяет значения переменных `x` и `y` местами.

==Сигнальные метки==
Напишем программу, определяющую, что натуральное число является [простым](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE):
```python
num = int(input()) 
flag = True 
for i in range(2, num): 
    if num % i == 0: # если исходное число делится на какое-либо отличное от 1 и самого себя 
    flag = False 
    
if num == 1: 
    print('Это единица, она не простая и не составная') 
elif flag == True: 
    print('Число простое') 
else: 
    print('Число составное')
```

#Примечания
<font color="#00b0f0">Примечание 1.</font> Аналогичным образом можно менять местами значения трех и более переменных.
```python
a, b, c, d = b, c, d, a
```

<font color="#00b0f0">Примечание 2.</font> Очень часто сигнальные метки называют `flag`.

<font color="#00b0f0">Примечание 3.</font> Поскольку в Python есть встроенные функции `max()` и `min()`, то давать такие названия для максимального и минимального значения не очень хорошо. Куда лучше использовать названия `largest` и `smallest` или `mx` и `mn`.

<font color="#00b0f0">Примечание 4.</font> Сумму чисел от 1 до 100, можно вычислить и без цикла:
![[Screenshot 2024-08-26 120846.png]]






#### 4. Цикл while

==Цикл while==
Иногда нужно, чтобы цикл выполнялся до наступления некоторого события, и количество итераций в этом случае заранее оценить просто невозможно. И здесь на помощь приходит цикл `while`.
```python
while условие: блок кода
```

Рассмотрим код, использующий цикл `while`, который распечатает 1010 раз слово `Привет`:
```python
i = 0 
while i < 10: 
    print('Привет') 
    i += 1
```
Такой код можно легко заменить циклом `for`

Напишем программу, которая считывает числа и выводит их квадраты, пока не будет введено −1. При такой постановке задачи мы не можем воспользоваться циклом `for`, так как не знаем, сколько чисел будет предшествовать числу −1.
```python
num = int(input()) 
while num != -1: 
    print('Квадрат вашего числа равен:', 
    num * num) 
    num = int(input())
```

**Важно:** если не изменять переменную `num` внутри цикла, то можно получить так называемый **бесконечный цикл**, который будет выполняться бесконечно много раз.

==Цикл for VS цикл while==

Напишем программу, выводящую все числа, кратные 33, используя цикл `for` и `while`:
```python
# используем for 
for i in range(0, 100, 3): 
    print(i) 
# используем while 
i = 0 
while i < 100: 
    print(i) 
    i += 3
```
Не всегда можно заменить while на for 

==Считывание данных до стоп значения==

```python
text = input() 
total = 0 
while text != 'stop': 
    total += int(text) 
    text = input() 
    
print('Сумма чисел равна', total)
```


==Бесконечный цикл==
Пример бесконечного цикла:
```python
i = 0 
total = 0 
while i < 10: 
    total += i
```

<font color="#00b0f0">Примечание </font>. Однократное выполнение тела цикла называется **итерацией** цикла.

<font color="#00b0f0">Примечание.</font> Графическое представление цикла `while` имеет вид:
![[Screenshot 2024-08-29 095844.png]]

<font color="#00b0f0">Примечание.</font> Условие в цикле `while`, как и в условном операторе `if`, может содержать логические операции `or`, `and`, `not`.








#### 5. Цикл while: обработка цифр числа

==Обработка цифр числа==

Пусть дано натуральное число `n`. Тогда:
- результатом операции `n % 10` – является последняя цифра числа;
- результатом операции `n // 10` – является число с удаленной последней цифрой.
```python
n = int(input()) 
while n != 0: 
    last_digit = n % 10  
    # получить последнюю цифру
    # код обработки последней цифры 
    n = n // 10 
    # удалить последнюю цифру из числа
```



#### 6. break, continue и else

==Оператор прерывания цикла break==

Усовершенствуем с помощью оператора `break` программу, проверяющую число на простоту:
```python
num = int(input()) 
flag = True 

for i in range(2, num): 
	if num % i == 0: # если исходное число делится на какое-либо отличное от 1 и самого себя 
	flag = False 
	break # останавливаем цикл если встретили делитель числа 

if flag: # эквивалентно if flag == True: 
	print('Число простое') 
else: 
	print('Число составное')
```

==Бесконечные циклы==

```python
while True: 
	print('Python is awesome!')
```
Бесконечный цикл продолжает повторяться до тех пор, пока программа не будет прервана. Изучив оператор `break`, мы получили механизм прерывания бесконечных циклов.

<font color="#00b0f0">Важно:</font> бесконечные циклы могут быть очень полезными. Просто помните, что вы должны убедиться, что цикл в какой-то момент будет прерван, чтобы он действительно не становился бесконечным.

==Оператор continue==

Оператор `continue` позволяет перейти к следующей итерации цикла `for` или `while` до завершения всех команд в теле цикла.

Напишем программу, которая выводит все числа от 1 до 100, кроме чисел 7, 17, 29 и 78.
```python
for i in range(1, 101): 
	if i == 7 or i == 17 or i == 29 or i == 78: 
		continue # переходим на следующую итерацию 
	print(i)
```

<font color="#00b0f0">Примечание 1.</font> Оператор `break` прерывает выполнение ближайшего цикла, а не программы, то есть далее будет выполнена команда, следующая сразу за циклом.

<font color="#00b0f0">Примечание 2.</font> Графическое представление операторов `break` и `continue` имеет вид:
![[Screenshot 2024-09-02 103207.png]]

==Блок else в циклах==
Python допускает необязательный блок `else` в конце циклов `while` и `for`. Это уникальная особенность Python, не встречающаяся в большинстве других языков программирования. Синтаксис такой конструкции следующий:
```python
while условие: 
	блок кода1 
else: 
	блок кода2 

# или 
for i in range(10): 
	блок кода1 
else: 
	блок кода2
```

<font color="#00b0f0">Примечание 1.</font> Оператор `continue` не влияет на выполнение блока `else` в циклах.

<font color="#00b0f0">Примечание 2.</font> Блок `else` в циклах часто применяется для обработки отсутствия элементов.

<font color="#00b0f0">Примечание 3.</font> Блок кода `else` в циклах встречается не так часто на практике. Однако если вы обнаружите ситуацию, в которой применение `else` оправдано, то не стесняйтесь его использовать. Это может добавить ясности вашему коду!


#### 7. Поис ошибок и ревью кода

==Ревью кода==

Ревью кода – проверка исходного кода программы с целью обнаружения и исправления ошибок и неточностей, которые остались незамеченными при начальной разработке.

- фактические ошибки;
- производительность кода;
- читабельность кода и ошибки форматирования кода.

Целью ревью кода является **улучшение качества программного кода** и **совершенствование навыков программиста**.
![[Screenshot 2024-09-02 122137.png]]

Хорошие статьи о ревью кода можно почитать на хабре:
1 - https://habr.com/ru/articles/340550/
2 - https://habr.com/ru/articles/342244/


#### 8. Вложенные циклы. Часть 1

==Вложенные циклы==

Часы служат хорошим примером работы вложенного цикла.
Рассмотрим цикл, который частично моделирует электронные часы.
```python
for hours in range(24): 
	for minutes in range(60): 
		for seconds in range(60): 
			print(hours, ':', minutes, ':', seconds)
```

Результатом работы такого кода будет:
```python
0 : 0 : 0 
0 : 0 : 1 
0 : 0 : 2 
... 
23 : 59 : 58 
23 : 59 : 59
```

 <font color="#00b0f0"> Мы можем вкладывать друг в друга циклы как for, так и while.</font>

==Операторы break и continue во вложенных циклах==

```python
for i in range(3): 
	for j in range(3): 
		print(i, j)
```
Результатом его выполнения будут 9 строк:
```python
0 0 
0 1 
0 2 
1 0 
1 1 
1 2 
2 0 
2 1 
2 2
```

Изменим код, добавив во вложенный цикл условный оператор с оператором `break`:
```python
for i in range(3): 
	for j in range(3): 
		if i == j: 
			break 
		print(i, j)
```


## Строковый тип данных

[[#1. Индексация]]
[[#2. Срезы]]
[[#3. Методы строк. Часть 1]]
[[#4. Методы строк. Часть 2]]
[[#5. Методы строк. Часть 3]]
[[#6. Форматирование строк]]
[[#7. Строки в памяти компьютера, таблица символов Unicode]]
[[#8. Сравнение строк]]


#### 1. Индексация

==Индексация строк==
Пусть `s = 'Python'`. Таблица ниже, показывает как работает индексация:
![[Screenshot 2024-09-04 173018.png]]

А так же можно его обратный вариант:
![[Screenshot 2024-09-04 173540.png]]

==Итерирование строк==
Напишем программу, которая выводит каждый символ строки на отдельной строке:
```python
s = 'abcdef' 
for i in range(len(s)): 
	print(s[i])

# Результатом выполнения такой программы будут строки:
a 
b
c 
d 
e 
f
```
Мы передаем в функцию `range()` длину строки `len(s)`. В нашем случае длина строки `s`, равна 66. Таким образом, вызов функции `range(len(s))` имеет вид `range(6)` и переменная цикла `i` последовательно перебирает все значения от 00 до 55. Это означает, что выражение `s[i]` последовательно вернет все символы строки `s`. Такой способ итерации строки удобен, когда нам нужен не только сам элемент `s[i]`, но и его индекс `i`.

Если нам не нужен индекс самого символа, то мы можем использовать более короткий способ итерации
```python
s = 'abcdef' 
for c in s: 
	print(c)
```

<font color="#00b0f0">Обратите внимание на обозначение переменных цикла. В первом цикле мы используем имя `i`, что соответствует стандартной идеологии наименования переменных цикла. Во втором цикле, мы назвали переменную буквой `c` – первая буква слова char (символ).</font>


#### 2. Срезы

==Срезы строк==
Следующий программный код:
```python
print(s[2:5]) 
print(s[0:6]) 
print(s[2:7])

# выводит:
cde 
abcdef 
cdefg
```
![[Screenshot 2024-09-05 152956.png]]

==Срез до конца, от начала==
Если опустить второй параметр в срезе `s[x:]` (но поставить двоеточие), то срез берется до конца строки. Аналогично если опустить первый параметр `s[:y]`, то можно взять срез от начала строки. Срез `s[:]` совпадает с самой строкой `s`.

<font color="#00b0f0">Срез `s[:]` возвращает исходную строку.</font>

==Отрицательные индексы в срезе==
Мы также можем использовать отрицательные индексы для создания срезов. Как уже говорилось ранее, отрицательные индексы строки начинаются с `-1` и отсчитываются до достижения начала строки.

==Шаг среза==
![[Screenshot 2024-09-05 153303.png]]

==Отрицательный шаг среза==
Следующий программный код:
```python
print(s[::-1])

# выводит:
jihgfedcba
```

==Подводя итог==
![[Screenshot 2024-09-05 153457.png]]

==Изменение символа строки по индексу==
Предположим, у нас есть строка `s = 'abcdefghij'` и мы хотим заменить символ с индексом 4 на `'X'`. 
Если мы хотим поменять какой-либо символ строки `s`, мы должны создать новую строку. Следующий код использует срезы и решает поставленную задачу:
```python
s = s[:4] + 'X' + s[5:]
```

<font color="#00b0f0">Примечание 1.</font> Синтаксис срезов строк очень похож на синтаксис функции `range()`.

<font color="#00b0f0">Примечание 2.</font> Если первый параметр среза больше второго, то срез создает пустую строку.


#### 3. Методы строк. Часть 1

==Методы и функции==
Таким образом: метод — функция, применяемая к объекту. В данном случае к строке. Метод вызывается в виде `имя_объекта.имя_метода(параметры)`.
Например, `s.find('e')` — это применение к строке `s` метода `find` с одним параметром `'e'`.

==Метод capitalize()==

Метод `capitalize()` возвращает копию строки `s`, в которой первый символ имеет верхний регистр, а все остальные символы имеют нижний регистр.
```python
s = 'foO BaR BAZ quX' 
print(s.capitalize())

# выйдет
Foo bar baz qux
```

Символы, не являющиеся буквами алфавита, остаются неизменными. Результатом выполнения следующего кода:
```python
s = 'foo123#BAR#.' 
print(s.capitalize())

# выйдет
Foo123#bar#.
```

==Метод swapcase()==

Метод `swapcase()` возвращает копию строки `s`, в которой все символы, имеющие верхний регистр, преобразуются в символы нижнего регистра и наоборот.
```python
s = 'FOO Bar 123 baz qUX' 
print(s.swapcase())

# выйдет
foo bAR 123 BAZ Qux
```

==Метод title()==
Метод `title()` возвращает копию строки `s`, в которой первый символ каждого слова переводится в верхний регистр.
```python
s = 'the sun also rises' 
print(s.title())

# выйдет 
The Sun Also Rises
```

==Метод lower()==
Метод `lower()` возвращает копию строки `s`, в которой все символы имеют нижний регистр.
```python
s = 'FOO Bar 123 baz qUX' 
print(s.lower())

# выйдет 
foo bar 123 baz qux
```

==Метод upper()==
Метод `upper()` возвращает копию строки `s`, в которой все символы имеют верхний регистр.
```python
s = 'FOO Bar 123 baz qUX' 
print(s.upper())

# выйдет 
FOO BAR 123 BAZ QUX
```
Одно очень важное замечание о методах данной категории состоит в том, что они не изменяют исходную строку. Если вы хотите изменить строку `s`, нужно написать код: `s = s.lower()`. На самом деле тут вы создаёте совсем другой объект в памяти компьютера, просто он со старым названием `s`.

#Примечание
Англо - русский словарик:  
capitalize - писать прописными буквами, закрепить. swapcase - обменять регистр. swap — гл. обмениваться, case — случай, регистр, падеж, дело, расследование...  
title — заголовок, титул.  
lower — нижний.  
upper — верхний.


#### 4. Методы строк. Часть 2

==Поиск и замена==

Каждый метод в этой группе поддерживает необязательные аргументы `<start>` и `<end>`. Как и в строковых срезах действие метода ограничено частью исходной строки, начинающейся с позиции символа `<start>` и продолжающейся вплоть до позиции символа `<end>`, но не включающей ее. Если параметр `<start>` указан, а параметр `<end>` нет, то метод применяется к части исходной строки от `<start>` до конца строки. Если параметры не заданы, то подразумевается, что `<start> = 0`, `<end> = len(s)`.

==Метод count()==
Вот код :
```python
s = 'foo goo moo' 
print(s.count('oo')) 
print(s.count('oo', 0, 8)) # подсчет с 0 по 7 символ

# выводит:
3
2
```


==Метод startswith()==

Вот код:
```python
s = 'foobar' 
print(s.startswith('foo')) print(s.startswith('baz'))

# выводит:
True 
False
```

==Метод endswith()==

Вот код:
```python
s = 'foobar' 
print(s.endswith('bar')) print(s.endswith('baz'))

# выводит:
True
False
```

==Методы find(), rfind()==

Метод `find(<sub>, <start>, <end>)` находит **индекс первого вхождения** подстроки `<sub>` в исходной строке `s`. Если строка `s` не содержит подстроки `<sub>`, то метод возвращает значение `-1`. Мы можем использовать данный метод наравне с оператором `in` для проверки: содержит ли заданная строка некоторую подстроку или нет.
```python
s = 'foo bar foo baz foo qux' print(s.find('foo')) 
print(s.find('bar')) 
print(s.find('qu')) 
print(s.find('python'))

# выводит:
0 
4 
20 
-1
```
Метод `rfind(<sub>, <start>, <end>)` идентичен методу `find(<sub>, <start>, <end>)`, за тем исключением, что он ищет первое вхождение подстроки `<sub>`, начиная с конца строки `s`.

==Методы index(), rindex()==

Метод `index(<sub>, <start>, <end>)` идентичен методу `find(<sub>, <start>, <end>)`, за тем исключением, что он **вызывает ошибку** `ValueError: substring not found` во время выполнения программы, если подстрока `<sub>` не найдена.

Метод `rindex(<sub>, <start>, <end>)` идентичен методу `index(<sub>, <start>, <end>)`, за тем исключением, что он ищет первое вхождение подстроки `<sub>`, начиная с конца строки `s`.

Методы `find()` и `rfind()` являются более безопасными чем `index()` и `rindex()`, так как не приводят к возникновению ошибки во время выполнения программы.

==Метод strip()==

Метод `strip()` возвращает копию строки `s`, у которой удалены все пробелы, стоящие **в начале и конце** строки.
```python
s = ' foo bar foo baz foo qux ' print(s.strip())

# выводит:
foo bar foo baz foo qux
```

==Метод lstrip()==

Метод `lstrip()` возвращает копию строки `s`, у которой удалены все пробелы, стоящие **в начале** строки.
```python
s = ' foo bar foo baz foo qux ' print(s.lstrip())

# выводит:
foo bar foo baz foo qux⎵ ⎵ ⎵ ⎵ ⎵ ⎵
```

==Метод rstrip()==

Метод `rstrip()` возвращает копию строки `s`, у которой удалены все пробелы, стоящие **в конце** строки.
```python
s = ' foo bar foo baz foo qux ' print(s.rstrip())

# выводит:
⎵ ⎵ ⎵ ⎵ ⎵ ⎵foo bar foo baz foo qux
```
Методы `strip()`, `lstrip()`, `rstrip()` могут принимать на вход опциональный аргумент`<chars>`. Необязательный аргумент `<chars>`– это строка, которая определяет набор символов для удаления.

==Метод replace()==

Метод `replace(<old>, <new>)` возвращает копию `s` **со всеми** вхождениями подстроки `<old>`, замененными на `<new>`.
```python
s = 'foo bar foo baz foo qux' print(s.replace('foo', 'grault'))

# выводит:
grault bar grault baz grault qux
```
Метод `replace()` может принимать опциональный третий аргумент `<count>`, который определяет количество замен.
```python
s = 'foo bar foo baz foo qux' print(s.replace('foo', 'grault', 2))

# выводит:
grault bar grault baz foo qux
```



#### 5. Методы строк. Часть 3

==Метод isalnum()==
Приведённый ниже код:\
```python
s1 = 'abc123' 
s2 = 'abc$*123' 
s3 = '' 
print(s1.isalnum()) 
print(s2.isalnum()) 
print(s3.isalnum())

# выводит:
True 
False 
False
```

```python
s1 = 'BEEGEEK' 
s2 = '2202'
  
print(s1.isalnum()) 
print(s2.isalnum())

# выводит:
True 
True
```

==Метод isalpha()==
Приведённый ниже код:
```python
s1 = 'ABCabc' 
s2 = 'abc123' 
s3 = '' 
print(s1.isalpha()) 
print(s2.isalpha()) 
print(s3.isalpha())

# выводит:
True 
False 
False
```

==Метод isdigit()==
Приведённый ниже код:
```python
s1 = '1234567' 
s2 = 'abc123' 
s3 = '' 
print(s1.isdigit()) 
print(s2.isdigit()) 
print(s3.isdigit())

# выводит:
True 
False
False
```

==Метод islower()==
Приведённый ниже код:
```python
s1 = 'abc' 
s2 = 'abc1$d' 
s3 = 'Abc1$D' 
print(s1.islower()) 
print(s2.islower()) 
print(s3.islower())

# выводит:
True 
True 
False
```
<font color="#00b0f0">Обратите внимание, что метод islower() игнорирует все небуквенные символы.</font>

==Метод isupper()==
Приведённый ниже код:
```python
s1 = 'ABC' 
s2 = 'ABC1$D' 
s3 = 'Abc1$D' 
print(s1.isupper()) 
print(s2.isupper()) 
print(s3.isupper())

# выводит:
True 
True 
False
```
<font color="#00b0f0">Обратите внимание, что метод isupper() игнорирует все небуквенные символы.</font>

==Метод isspace()==
Приведённый ниже код:
```python
s1 = ' ' 
s2 = 'abc1$d' 
print(s1.isspace()) 
print(s2.isspace())

# выводит:
True 
False
```


#### 6. Форматирование строк

==Метод format()==
Рассмотрим следующий код:
```python
birth_year = 1992 
text = 'My name is Timur, I was born in ' + str(birth_year) 
print(text)

# выводит:
My name is Timur, I was born in 1992
```
Такой код работает, но каждый раз преобразовывать число в строку не очень удобно. Для более наглядного форматирования мы можем использовать строковый метод `format()`.

Предыдущий код можно переписать в виде:
```python
birth_year = 1992 
text = 'My name is Timur, I was born in {}'.format(birth_year) 
print(text)
```

Мы передаем необходимые параметры методу `format()`, а Python ставит их вместо фигурных скобок `{}` – **заполнителей**. Мы можем создавать сколько угодно заполнителей.
```python
birth_year = 1992 
name = 'Timur' 
profession = 'math teacher' 
text = 'My name is {}, I was born in {}, I work as a {}.'.format(name, birth_year, profession) 
print(text)

# выводит:
My name is Timur, I was born in 1992, I work as a math teacher.
```
Для наглядности и гибкости форматирования мы можем использовать порядковый номер в заполнителе: `{0}`, `{1}`, `{2}` и т.д. Такой номер определяет позицию параметра, переданного методу `format()` (нумерация начинается с нуля):

Параметр `name` встает в заполнителе `{0}`, параметр `birth_year` – в заполнителе `{1}` и т.д. Мы можем использовать одно и то же число в нескольких заполнителях или не использовать совсем, а также мы можем использовать числа в разном порядке.


==f-строки==

Предыдущий код можно записать в виде:
```python
first_name = 'Taylor' 
last_name = 'Swift' 
country = 'USA' 
birth_date = '1989/12/13' 
birth_place = 'West Reading, Pennsylvania' text = f'{first_name} {last_name} is a very famous singer from the {country}. She was born on {birth_date} in {birth_place}.' print(text)
```


**Примечание 1.** Почитать подробнее про форматирование строк можно в официальной документации по [ссылке](https://docs.python.org/3/library/string.html#formatstrings). Отдельно можно почитать на английском языке про метод `format()` и f-строки по [ссылке](https://docs.python.org/3/library/stdtypes.html#str.format) и по [ссылке](https://docs.python.org/3/reference/lexical_analysis.html#f-strings).

**Примечание 2.** На русском языке можно почитать про форматирование строк по [ссылке](https://docs-python.ru/tutorial/operatsii-tekstovymi-strokami-str-python/metod-str-format/) и по [ссылке](https://docs-python.ru/tutorial/operatsii-tekstovymi-strokami-str-python/stroki-formatirovannye-stroki/).

**Примечание 3.** Про эволюцию форматирования в Python вы можете почитать в нашем официальном блоге на Хабре по [ссылке](https://habr.com/ru/articles/828396/).

**Примечание 4.** До версии Python 3.12 повторное использование тех же кавычек, что и окружающие f-строку, вызывает ошибку синтаксиса.


#### 7. Строки в памяти компьютера, таблица символов Unicode

==Таблица символов ASCII==
ASCII представляет собой набор из 128 цифровых кодов, которые обозначают английские буквы, различные знаки препинания и другие символы. Например, код ASCII для прописной английской буквы «А» (латинской) равняется 65. Когда на компьютерной клавиатуре вы набираете букву «А» в верхнем регистре, в памяти сохраняется число 65 (как двоичное число, разумеется).

![](https://ucarecdn.com/0e7a9757-5bae-4d65-a241-8910e1bf4e0f/)

Код ASCII для английской «В» в верхнем регистре равняется 66, для «С» в верхнем регистре – 67 и т. д. **На один символ в ASCII отводится ровно 7 бит.**  

==ASCII table==
![[Screenshot 2024-09-19 085418.png]]


==Функция ord()==
Приведенный ниже код:
```python
num1 = ord('A') 
num2 = ord('B') 
num3 = ord('a') 
print(num1, num2, num3)

# выводит:
65 66 97
```
Обратите внимание, что функция `ord()` принимает именно **одиночный символ**. Если попытаться передать строку, содержащую более одного символа, мы получим ошибку времени выполнения.

Название функции `ord()` происходит от английского слова «order» — порядок.

==Функция chr()==
Приведенный ниже код:
```python
chr1 = chr(65)
chr2 = chr(75)
chr3 = chr(110)

print(chr1, chr2, chr3)

# выводит:
A K n
```
 Название функции `chr()` происходит от английского слова «character» — символ.

Функции `ord()` и `chr()` часто работают в паре. Мы можем использовать следующий код для вывода всех заглавных букв английского алфавита:
```python
for i in range(26): print(chr(ord('A') + i))

# Приведенный выше код выводит:
A 
B 
C 
...
X 
Y 
Z
```

#Примечания
**Примечание 1.** Функции `ord()` и `chr()` являются **взаимно обратными**. Для них выполнены равенства:
`chr(ord(<символ>)) = <символ>`
`ord(chr(<код символа>)) = <код символа>`
Приведенный ниже код:
```python
print(chr(ord('A')) == 'A') print(ord(chr(65)) == 65)

# выводит:
True 
True
```

**Примечание 2.** Обратите внимание, что некоторые символы могут выглядеть одинаково, но на самом деле иметь **разные коды** в таблице Unicode. Это в первую очередь касается букв, которые имеют одинаковое написание на разных языках.
```python
print(ord('a')) # английская буква «a» 
print(ord('а')) # русская буква «а»

# выводит:
97 
1072
```
Также можно заметить, что в таблице Unicode русские буквы находятся гораздо **дальше**
английских.

#### 8. Сравнение строк

==Сравнение строк единичной длины==
Начнем с примера сравнения строк, состоящих из одного символа. В Python это сравнение происходит путем сравнения кодов этих символов в таблице Unicode.
```python
print('a' > 'b') 
print('a' < 'z')

# выводит:
False 
True
```
Предыдущий код полностью эквивалентен следующему коду:
```python
print(ord('a') > ord('b')) print(ord('a') < ord('z'))
```
Подробнее ознакомиться с таблицей символов Unicode можно по [ссылке](https://symbl.cc/en/unicode-table/). Обычно на практике достаточно оперировать [таблицей ASCII](https://www.asciitable.com/), которая является подмножеством таблицы Unicode. Первые 128 символов таблицы Unicode совпадают с таблицей ASCII.

==Сравнение строк не единичной длины==

**Алгоритм сравнения строк:**
1. Начинаем с первых символов каждой строки. Если символы равны, переходим к следующей паре символов
2. Когда находим первый отличающийся символ, строка с меньшим символом считается "меньше"
3. Если одна из строк заканчивается раньше, то более короткая считается "меньше"

**Пример 1.** Сравним строки `'hello'` и `'hell'`.
- Сравнение первых символов: `h` и `h` – оба символа равны, переходим к следующей паре символов
- Сравнение вторых символов: `e` и `e` – оба символа равны, переходим к следующей паре символов
- Сравнение третьих символов: `l` и `l` – оба символа равны, переходим к следующей паре символов
- Сравнение четвертых символов: `l` и `l` – оба символа равны, переходим к следующей паре символов
- Сравнение пятых символов: `o` (у первой строки) и отсутствующий символ (у второй строки) – вторая строка закончилась

<font color="#00b0f0">Обратите внимание</font>, что в Python сравнение останавливается, как только находится первое различие между символами на соответствующих позициях. Дальнейшее сравнение символов не требуется.


**Примечание 1.** Нельзя путать сравнение чисел и сравнение строк, содержащих эти числа.
```python
print(10 > 9) 
print('10' > '9')

# выводит:
True 
False
```

**Примечание 2.** Мы можем сравнивать не только строки, состоящие из букв латинского алфавита, но и строки, состоящие из любых символов, которые входят в таблицу Unicode. Алгоритм сравнения строк при этом будет аналогичный – в соответствии с кодами символов в таблице Unicode.
```python
print('Тинькофф' == 'Т-банк') 
print('¥' > '$€£') 
print(max('🐷', '🦆', '🐔'))

# выводит:
False 
True 
🦆
```

**Примечание 3.** В Python не поддерживается операция сравнения строк и чисел друг с другом.
```python
print('45' > 44)

# приводит к возникновению ошибки:
TypeError: '>' not supported between instances of 'str' and 'int'
```

**Примечание 4.** В Python встроенные функции `min()` и `max()` могут принимать строки в качестве аргументов и сравнивают их лексикографически (используя порядок символов в кодировке Unicode). Как несложно догадаться, функция `min()` вернёт самую "маленькую" строку, а `max()` – самую "большую" строку.
```python
print(max('tree', 'try', 'true')) 
print(min('cat', 'car', 'cape'))

# выводит:
try 
cape
```
Обратите внимание, что мы не можем **одновременно** передавать строки и числа в качестве аргументов в функции `min()` и `max()`. Это является следствием того, что мы не можем сравнивать строки с числами.
```python
print(min('2', 8, '45', 90))

# приводит к возникновению ошибки:
TypeError: '<' not supported between instances of 'int' and 'str'
```



## Списки

[[#1. Введение в списки]]
[[#2. Основы работы со списками]]
[[#3. Методы списков. Часть 1]]
[[#4. Вывод элементов списка]]
[[#5. Методв строк split, join]]
[[#6. Методы списков. Часть 2]]
[[#7. Списочное вырожение]]
[[#8. Сортировка списков]]

#### 1. Введение в списки

==Списки==
Структура данных (data structure) — программная единица, позволяющая **хранить и обрабатывать** множество однотипных и/или логически связанных данных.

Список представляет собой последовательность элементов, пронумерованных от 0, как символы в строке.

==Создание списка==
Чтобы создать список, нужно перечислить его элементы через запятую в квадратных скобках:
```python
numbers = [2, 4, 6, 8, 10] 
languages = ['Python', 'C#', 'C++', 'Java']
```
Список `numbers` состоит из 5 элементов, и каждый из них — целое число.
```python
numbers[0] == 2
numbers[1] == 4
numbers[2] == 6
numbers[3] == 8
numbers[4] == 10
```
Список `languages` состоит из 4 элементов, каждый из которых — **строка.**
```python
languages[0] == 'Python'
languages[1] == 'C#'
languages[2] == 'C++'
languages[3] == 'Java'
```
 Значения, заключенные в квадратные скобки и отделенные запятыми, называются **элементами списка**.

Список может содержать значения **разных типов данных**:
```python
info = ['Timur', 1992, 61.5]
```

==Пустой список==
Следующие две строки кода создают пустой список:
```python
mylist = [] # пустой список 
mylist = list() # тоже пустой список
```

==Вывод списка==
Для вывода всего списка можно применить функцию `print()`:

==Встроенная функция list==
Во время исполнения этого кода происходит следующее:
1. Вызывается функция `range()`, в которую в качестве аргумента передается число 5;
2. Эта функция возвращает последовательность чисел `0, 1, 2, 3, 4`;
3. Последовательность чисел `0, 1, 2, 3, 4` передается в качестве аргумента в функцию `list()`;
4. Функция `list()` возвращает список `[0, 1, 2, 3, 4]`;
5. Список `[0, 1, 2, 3, 4]` присваивается переменной `numbers`.


**Примечание 1.** Как уже было сказано, списки в Python аналогичны массивам в других языках программирования. Однако разница между списками и массивами все же существует. Элементы массива всегда имеют одинаковый тип данных и располагаются в памяти компьютера непрерывным блоком, а элементы списка могут быть разбросаны по памяти как угодно и могут иметь разный тип данных.

**Примечание 2.** Обратите внимание, при выводе содержимого списка с помощью функции `print()`, все строковые элементы списка обрамляются **одинарными кавычками**. Если требуется осуществить вывод в двойных кавычках, нужно самостоятельно писать код вывода.


#### 2. Основы работы со списками

==Функция len()==
Следующий программный код:
```python
numbers = [2, 4, 6, 8, 10] 
languages = ['Python', 'C#', 'C++', 'Java'] print(len(numbers)) # выводим длину списка numbers 
print(len(languages)) # выводим длину списка languages 
print(len(['apple', 'banana', 'cherry'])) # выводим длину списка, состоящего из 3 элементов

# выведет:
5 
4 
3
```

==Оператор принадлежности in==
Рассмотрим следующий код:
```python
numbers = [2, 4, 6, 8, 10] 
if 2 in numbers: 
	print('Список numbers содержит число 2') else: 
	print('Список numbers не содержит число 2')
```

Мы можем использовать оператор `in` вместе с логическим оператором `not`. Например
```python
numbers = [2, 4, 6, 8, 10]

if 0 not in numbers:
    print('Список numbers не содержит нулей')
```

==Использование срезов для изменения элементов в заданном диапазоне==
Следующий программный код:
```python
fruits = ['apple', 'apricot', 'banana', 'cherry', 'kiwi', 'lemon', 'mango'] fruits[2:5] = ['банан', 'вишня', 'киви'] print(fruits)

# выводит:
['apple', 'apricot', 'банан', 'вишня', 'киви', 'lemon', 'mango']
```

==Операция конкатенации + и умножения на число *==

Мы можем применять операторы `+` и `*` для списков подобно тому, как мы это делали со строками.
```python
print([1, 2, 3, 4] + [5, 6, 7, 8]) 
print([7, 8] * 3) 
print([0] * 10)

# выводит:
[1, 2, 3, 4, 5, 6, 7, 8] 
[7, 8, 7, 8, 7, 8] 
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

Мы также можем использовать расширенные операторы `+=` и `*=` при работе со списками.
```python
a = [1, 2, 3, 4] 
b = [7, 8] 
a += b # добавляем к списку a список b 
b *= 5 # повторяем список b 5 раз print(a) print(b)

# выводит:
[1, 2, 3, 4, 7, 8] 
[7, 8, 7, 8, 7, 8, 7, 8, 7, 8]
```


==Встроенные функции sum(), min(), max()==
Встроенная функция `sum()` принимает в качестве параметра список чисел и вычисляет сумму его элементов.
```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
print('Сумма всех элементов списка =', sum(numbers))

# выводит:
Сумма всех элементов списка = 55
```
Встроенные функции `min()` и `max()` принимают в качестве параметра список и находят минимальный и максимальный элементы соответственно.

==Отличие списков от строк==
Несмотря на всю схожесть списков и строк, есть одно очень важное отличие: строки — **неизменяемые** объекты, а списки – **изменяемые**.

**Запомни:** изменять отдельные символы строк нельзя, однако можно изменять отдельные элементы списков. Для этого используем индексатор и оператор присваивания.



#### 3. Методы списков. Часть 1

==Метод append()==
Для добавления нового элемента **в конец списка** используется метод `append()`.
```python
numbers = [1, 1, 2, 3, 5, 8, 13] # создаем список 
numbers.append(21) # добавляем число 21 в конец списка 
numbers.append(34) # добавляем число 34 в конец списка 
print(numbers)

# выведет:
[1, 1, 2, 3, 5, 8, 13, 21, 34]
```
Обратите внимание, для того чтобы использовать метод `append()`, нужно, чтобы список был создан (при этом он может быть пустым).
```python
numbers = [] # создаем пустой список 
numbers.append(1) 
numbers.append(2) 
numbers.append(3) 
print(numbers)

# выведет:
[1, 2, 3]
```
**Важно:** мы не можем использовать индексаторы для установки значений элементов списка, если список пустой. Следующий программный код:
```python
numbers = []  # создаем пустой список

numbers[0] = 1
numbers[1] = 2
numbers[2] = 3

print(numbers)

# приводит к ошибке:
IndexError: list assignment index out of range
```

==Метод extend()==
Можно также расширить список другим списком путем вызова метода `extend()`.
```python
numbers = [0, 2, 4, 6, 8, 10] 
odds = [1, 3, 5, 7] 
numbers.
extend(odds) 
print(numbers)

# выведет:
[0, 2, 4, 6, 8, 10, 1, 3, 5, 7]
```

Отличие между методами `append()` и `extend()` проявляется при добавлении строки к списку.
```python
words1 = ['iq option', 'stepik', 'beegeek'] words2 = ['iq option', 'stepik', 'beegeek'] words1.append('python') words2.extend('python') 
print(words1) 
print(words2)

# выведет:
['iq option', 'stepik', 'beegeek', 'python'] 
['iq option', 'stepik', 'beegeek', 'p', 'y', 't', 'h', 'o', 'n']
```
Метод `append()` добавляет строку `'python'` целиком к списку, а метод `extend()` разбивает строку `'python'` на  символы `'p'`, `'y'`, `'t'`, `'h'`, `'o'`, `'n'` и их добавляет в качестве элементов списка.

==Удаление элементов==

С помощью оператора `del` можно удалять элементы списка по определенному индексу.
```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] 
del numbers[5] # удаляем элемент имеющий индекс 5 
print(numbers)

# выведет:
[1, 2, 3, 4, 5, 7, 8, 9]
```
Обратите внимание на синтаксис удаления, так как он отличается от обычного вызова метода. При удалении элементов не надо передавать аргумент внутри круглых скобок.

Оператор `del` работает и со срезами: мы можем удалить целый диапазон элементов списка.
```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] 
del numbers[2:7] # удаляем элементы с 2 по 6 включительно 
print(numbers)

# выведет:
[1, 2, 8, 9]
```

Мы можем удалить все элементы на четных позициях (0, 2, 4, ...) исходного списка.
```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] 
del numbers[::2] 
print(numbers)

# выведет:
[2, 4, 6, 8]
```


#### 4. Вывод элементов списка

==Вывод с помощью цикла for==

**Вариант 1.** Если нужны индексы элементов:
```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 

for i in range(len(numbers)):
	print(numbers[i])
```

**Вариант 2.** Если индексы не нужны:
```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 

for num in numbers: 
	print(num)
```

==Вывод с помощью распаковки списка==

**Вариант 1.** Вывод элементов списка через один символ пробела:
```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(*numbers)

# Такой код выведет:
0 1 2 3 4 5 6 7 8 9 10
```

**Вариант 2.** Вывод элементов списка, каждого на отдельной строке
```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(*numbers, sep='\n')

# Такой код выведет:
0 
1 
2 
3 
4 
5 
6 
7
8 
9 
10
```
Поскольку строки содержат символы, подобно тому, как списки содержат элементы, то мы можем использовать распаковку строк точно так же, как и распаковку списков.

```python
s = 'Python' 
print(*s) 
print() 
print(*s, sep='\n')

# выведет:
P y t h o n 

P 
y 
t
h 
o 
n
```



#### 5. Методы строк: split, join

==Метод split()==
Метод `split()` разбивает строку на слова, используя в качестве разделителя последовательность пробельных символов, и возвращает список из этих слов.
```python
s = 'Python is the most powerful language' 
words = s.split() 
print(words)

# выводит:
['Python', 'is', 'the', 'most', 'powerful', 'language']
```

![[Screenshot 2024-09-25 090449.png]]

Рассмотрим следующий программный код:
```python
numbers = input().split()
```
Если при запуске этой программы ввести строку `1 2 3 4 5`, то список `numbers` будет следующим  `['1', '2', '3', '4', '5']`. Обратите внимание, что список будет состоять из строк (тип `str`), а не из чисел (тип `int`). Если требуется получить именно список чисел, то затем нужно элементы списка по одному преобразовать в числа с помощью команды `int()`.
```python
numbers = input().split() 
for i in range(len(numbers)): 
	numbers[i] = int(numbers[i]) print(numbers)

# выводит (если на вход программе была подана строка `1 2 3 4 5`):
[1, 2, 3, 4, 5]
```

==Необязательный параметр==
У метода `split()` есть необязательный параметр, который определяет, какой набор символов будет использоваться в качестве разделителя между элементами списка. Например, вызов метода `split('.')` вернёт список, полученный разделением исходной строки по символу `'.'`.
```python
ip = '192.168.1.24' 
numbers = ip.split('.') # указываем явно разделитель 
print(numbers)

# выводит:
['192', '168', '1', '24']
```

![[Screenshot 2024-09-25 092258.png]]

==Метод join()==

Метод `join()` собирает строку из элементов списка, используя в качестве разделителя строку, к которой применяется метод.
```python
words = ['Python', 'is', 'the', 'most', 'powerful', 'language'] 
s = ' '.join(words) 
print(s)

# выводит:
Python is the most powerful language
```

![[Screenshot 2024-09-25 092617.png]]

**Запомни:** строковый метод `split()` служит для преобразования строки в список, а метод `join()` — для преобразования списка в строку.

**Примечание 1.** Существует большая разница между результатами вызова методов `s.split()` и `s.split(' ')`. Разница в поведении проявляется, когда строка содержит несколько пробелов между словами.
Если в строке встречаются последовательные разделители, то они будут считаться как отдельные разделители, и между ними будет создана пустая строка (`''`).

**Примечание 2.** Методы `split()` и `join()` являются строковыми методами, они не могут применяться к спискам!

**Примечание 3.** Строковый метод `join()` не работает для списков, у которых элементы не строкового типа данных.

**Примечание 4.** На самом деле, метод `join()` в качестве аргумента может принимать не только список, но и строку.


#### 6. Методы списков. Часть 2

==Метод insert()==
Метод `insert()` позволяет вставлять значение в список в заданной позиции. В него передается два аргумента:

1. `index`: индекс, задающий место вставки значения;
2. `value`: значение, которое требуется вставить.

```python
names = ['Gvido', 'Roman' , 'Timur'] 
print(names) 
names.insert(0, 'Anders') 
print(names) 
names.insert(3, 'Josef') 
print(names)

# выведет:
['Gvido', 'Roman' , 'Timur'] 
['Anders', 'Gvido', 'Roman' , 'Timur'] 
['Anders', 'Gvido', 'Roman' , 'Josef', 'Timur']
```

==Метод index()==

Метод `index()` возвращает индекс первого элемента, значение которого равняется переданному в метод значению. Таким образом, в метод передается один параметр:

1. `value`: значение, индекс которого требуется найти.
```python
names = ['Gvido', 'Roman' , 'Timur'] 
position = names.index('Timur') 
print(position)

# выведет:
2
```

==Метод remove()==
Метод `remove()` удаляет первый элемент, значение которого равняется переданному в метод значению. В метод передается один параметр:

1. `value`: значение, которое требуется удалить.
```python
food = ['Рис', 'Курица', 'Рыба', 'Брокколи', 'Рис'] print(food) 
food.remove('Рис') 
print(food)

# выведет:
['Рис', 'Курица', 'Рыба', 'Брокколи', 'Рис'] 
['Курица', 'Рыба', 'Брокколи', 'Рис']
```
**Важно:** метод `remove()` удаляет только первый элемент с указанным значением. Все последующие его вхождения остаются в списке. Чтобы удалить все вхождения нужно использовать цикл `while` в связке с оператором принадлежности `in` и методом `remove`.

==Метод pop()==

Метод `pop()` удаляет элемент по указанному индексу и возвращает его. В метод `pop()` передается один **необязательный** аргумент:

1. `index`: индекс элемента, который требуется удалить.
```python
names = ['Gvido', 'Roman' , 'Timur'] 
item = names.pop(1) 
print(item) 
print(names)

# выведет:
Roman 
['Gvido', 'Timur']
```

==Метод count()==

Метод `count()` возвращает количество элементов в списке, значения которых равны переданному в метод значению. 

Таким образом, в метод передается один параметр:

1. `value`: значение, количество элементов, равных которому,  нужно посчитать.
```python
names = ['Timur', 'Gvido', 'Roman', 'Timur', 'Anders', 'Timur'] 
cnt1 = names.count('Timur') 
cnt2 = names.count('Gvido') 
cnt3 = names.count('Josef') 
print(cnt1) 
print(cnt2) 
print(cnt3)

# выведет:
3 
1 
0
```

==Метод reverse()==

Метод `reverse()` инвертирует порядок следования значений в списке, то есть меняет его на противоположный.
```python
names = ['Gvido', 'Roman' , 'Timur'] 
names.reverse() 
print(names)

# выведет:
['Timur', 'Roman', 'Gvido']
```
Существует большая разница между вызовом метода `names.reverse()` и использованием среза `names[::-1]`. Метод `reverse()` меняет порядок элементов на обратный **в текущем списке**, а срез создает копию списка, в котором элементы следуют в обратном порядке.

==Метод clear()==

Метод `clear()` удаляет все элементы из списка.
```python
names = ['Gvido', 'Roman' , 'Timur'] 
names.clear() 
print(names)

# выведет:
[]
```

==Метод copy()==

Метод `copy()` создает поверхностную копию списка.
```python
names = ['Gvido', 'Roman' , 'Timur'] 
names_copy = names.copy() # создаем поверхностную копию списка names 

print(names) 
print(names_copy)

# выведет:
['Gvido', 'Roman', 'Timur'] 
['Gvido', 'Roman', 'Timur']
```
Аналогичного результата можно достичь с помощью срезов или функции `list()`:
```python
names = ['Gvido', 'Roman' , 'Timur'] 
names_copy1 = list(names) # создаем поверхностную копию с помощью функции list() 
names_copy2 = names[:] # создаем поверхностную копию с помощью среза от начала до конца
```

==Метод sort()==
В Python списки имеют встроенный метод `sort()`, который сортирует элементы списка по возрастанию или убыванию.
```python
a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6, 8, -2, 99] 
a.sort() 
print('Отсортированный список:', a)

# выведет:
Отсортированный список: [-67, -3, -2, 0, 1, 6, 7, 8, 9, 12, 34, 45, 99, 1000]
```
По умолчанию метод `sort()` сортирует список по возрастанию. Если требуется отсортировать список по убыванию, необходимо явно указать параметр `reverse = True`.
```python
a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6, 8, -2, 99] 
a.sort(reverse=True) # сортируем по убыванию 
print('Отсортированный список:', a)

# выведет:
Отсортированный список: [1000, 99, 45, 34, 12, 9, 8, 7, 6, 1, 0, -2, -3, -67]
```

**Примечание 1.** С помощью метода `sort()` можно сортировать списки содержащие не только числа, но и строки. В таком случае элементы списка сортируются в соответствии с [лексикографическим порядком](https://ru.wikipedia.org/wiki/%D0%9B%D0%B5%D0%BA%D1%81%D0%B8%D0%BA%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA).
```python
a = ['бета', 'альфа', 'дельта', 'гамма'] 
a.sort() 
print('Отсортированный список:', a)

# выведет:
Отсортированный список: ['альфа', 'бета', 'гамма', 'дельта']
```

**Примечание 2.** Метод `sort()` использует алгоритм [Timsort](https://ru.wikipedia.org/wiki/Timsort).


#### 7. Списочное вырожение 

==Создание списков==

Для того, чтобы создать список состоящий из 1010 нулей мы можем использовать следующий код:
```python
zeros = [] 
for i in range(10): 
	zeros.append(0)
```
Или сделать код проще:
```python
zeros = [0] * 10
```

Например, для создания списка целых чисел от 00 до 99, мы вынуждены писать такой код:
```python
numbers = [] 
for i in range(10): 
	numbers.append(i)
```

==Списочные выражения==

В Python есть механизм для создания списков из неповторяющихся элементов. Такой механизм называется — **списочное выражение** (list comprehension).
```python
numbers = [i for i in range(10)]
```

Общий вид списочного выражения следующий:
`[выражение for переменная in последовательность]`

==Примеры использования списочных выражений==

**1. Создать список, заполненный 10 нулями можно и при помощи списочного выражения:**
```python
zeros = [0 for i in range(10)]
```

**2. Создать список, заполненный квадратами целых чисел от 0 до 9 можно так:**
```python
squares = [i ** 2 for i in range(10)]
```

**3. Создать список, заполненный кубами целых чисел от 10 до 20 можно так:**
```python
cubes = [i ** 3 for i in range(10, 21)]
```

**4. Создать список, заполненный символами строки**
```python
chars = [c for c in 'abcdefg'] 
print(chars)
```

==Считывание входных данных==

Например, если сначала вводится число `n` – количество строк, а затем сами строки, то создать список можно так:
```python
n = int(input()) 
lines = [input() for _ in range(n)]
```
Можно опустить описание переменной `n`:
```python
lines = [input() for _ in range(int(input()))]
```
Если требуется считать список чисел, то необходимо добавить преобразование типов:
```python
numbers = [int(input()) for _ in range(int(input()))]
```

Списочные выражения часто используются для инициализации списков. В Python не принято создавать пустые списки, а затем заполнять их значениями, если можно этого избежать.

==Условия в списочном выражении==

В списочных выражениях можно использовать условный оператор. Например, если требуется создать список четных чисел от 0 до 20, то мы можем написать такой код:
```python
evens = [i for i in range(21) if i % 2 == 0]
```

==Вложенные циклы==

В списочном выражении можно использовать вложенные циклы.
```python
numbers = [i * j for i in range(1, 5) for j in range(2)] 
print(numbers)

# выведет список:
[0, 1, 0, 2, 0, 3, 0, 4]
```
Такой код равнозначен следующему:
```python
numbers = [] 
for i in range(1, 5): 
	for j in range(2): 
		numbers.append(i * j) 
print(numbers)
```

==Подводя итог==

Пусть `word = 'Hello', numbers = [1, 14, 5, 9, 12], words = ['one', 'two', 'three', 'four', 'five', 'six']`.
![[Screenshot 2024-09-26 123357.png]]


#### 8. Сортировка списков 

==Алгоритмы сортировки==

**Алгоритм сортировки** — это алгоритм упорядочивания элементов в списке. Алгоритмы сортировки оцениваются по скорости выполнения и эффективности использования памяти:

- время — основной параметр, характеризующий быстродействие алгоритма;
- память — ряд алгоритмов требует выделения дополнительной памяти под временное хранение данных.

<font color="#00b0f0">Алгоритмы сортировки, не потребляющие дополнительной памяти, относят к сортировкам на месте.</font>

==Основные алгоритмы сортировки==

**Медленные:**
1. Пузырьковая сортировка (Bubble sort);
2. Сортировка выбором (Selection sort);
3. Сортировка простыми вставками (Insertion sort).

**Быстрые:**
1. Сортировка Шелла (Shell sort);
2. Быстрая сортировка (Quick sort);
3. Сортировка слиянием (Merge sort);
4. Пирамидальная сортировка (Heap sort);
5. Сортировка TimSort (используется в Java и Python).

К алгоритмам, не основанным на сравнениях, можно отнести следующие:
1. Сортировка подсчетом (Counting sort)
2. Блочная сортировка (Bucket sort)
3. Поразрядная сортировка (Radix sort)

**Примечание 1.** Подробнее об алгоритмах сортировки можно почитать по [ссылке](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8).

**Примечание 2.** Мы называем некоторые алгоритмы сортировки **медленными**, поскольку они тратят много времени на сортировку больших списков. Например, если список содержит порядка миллиона элементов, то такие алгоритмы тратят часы, а то и дни на выполнение сортировки, в то время как быстрые алгоритмы справляются с задачей за секунды.

**Примечание 3.** Наглядную работу алгоритмов сортировки на разных входных данных можно посмотреть по [ссылке](https://www.toptal.com/developers/sorting-algorithms).

==Сортировка пузырьком==

Следующий программный код реализует алгоритм пузырьковой сортировки:
```python
a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6, 8, -2, 99] 
n = len(a) 

for i in range(n - 1): 
	for j in range(n - 1 - i): 
		if a[j] > a[j + 1]: # если порядок элементов пары неправильный 
			a[j], a[j + 1] = a[j + 1], a[j] # меняем элементы пары местами 
			
print('Отсортированный список:', a)

# Результатом выполнения такого кода будет:
Отсортированный список: [-67, -3, -2, 0, 1, 6, 7, 8, 9, 12, 34, 45, 99, 1000]
```

==Оптимизация алгоритма==
Алгоритм пузырьковой сортировки можно немного ускорить. Если на одном из очередных проходов окажется, что обмены больше не нужны, то это означает, что все элементы списка находятся на своих местах, то есть список отсортирован. Для реализации такого ускорения нужно воспользоваться сигнальной меткой, то есть флажком и оператором прерывания `break`.

==Сортировка выбором==

Алгоритм сортировки выбором также считается учебным и практически не применяется вне учебной литературы. На практике используют более эффективные алгоритмы.

==Сортировка простыми вставками==

Следующий программный код реализует алгоритм сортировки простыми вставками:
```python
a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6, 8, -2, 99] 
n = len(a) 

for i in range(1, n): 
	elem = a[i] # берем первый элемент из неотсортированной части списка 
	j = i 
	
	# пока элемент слева существует и больше нашего текущего элемента 
	while j >= 1 and a[j - 1] > elem: 
		# смещаем j-й элемент отсортированной части вправо 
		a[j] = a[j - 1] 
		# сами идём влево, дальше ищем место для нашего текущего элемента 
		j -= 1 
		
	# нашли место для нащего текущего элемента из неотсортированной части 
	# и вставляем его на индекс j в отсортированной части 
	a[j] = elem 
	
print('Отсортированный список:', a)

# Результатом выполнения такого кода будет:
Отсортированный список: [-67, -3, -2, 0, 1, 6, 7, 8, 9, 12, 34, 45, 99, 1000]
```

==Оптимизация алгоритма==
Алгоритм сортировки простыми вставками можно значительно ускорить, если осуществлять поиск нужной позиции для вставки очередного элемента из неотсортированной части списка с помощью [бинарного поиска](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA).


## Функции

[[#1. Функции без параметров]]
[[#2. Функции с параметрами]]
[[#3. Локальные и глобальные переменные]]
[[#4. Функции с возвратом значения. Часть 1]]
[[#5. Функции с возвратом значения. Часть 2]]
[[#6. Функции с возвратом значения. Часть 3]]


==Подсказка==
1. **Заголовок (сигнатура функции)**: Это имя функции и список параметров, заключенных в скобки, разделенных запятыми.
2. **Введение (docstring)**: Это строка документации, которая описывает назначение функции, как ее использовать, какие параметры она принимает, что она возвращает и другие важные детали.
3. **Тело функции**: Это блок кода, который содержит инструкции и выражения, которые выполняются при вызове функции.
4. **Инициализация**: Это любые операции или код, который должен быть выполнен перед использованием функции, например, объявление переменных или импорт необходимых модулей. Инициализация не всегда обязательна и может быть частью заголовка или тела функции.


#### 1. Функции без параметров

==Функции==
Вместо повторения кода для вывода прямоугольника, можно перенести  его в отдельную **функцию**  и вызвать ее 3 раза.
```python
def draw_box(): 
	for _ in range(5): 
		print('*' * 7)
```
Когда функция создана, чтобы увидеть результат ее работы, надо вызвать ее по имени:
```python
draw_box()
```
Теперь, чтобы изобразить 3 прямоугольника, можно написать код:
```python
draw_box() 
print() 
draw_box() 
print() 
draw_box()
```
Код стал короче, читабельнее (за счет удачного названия функции), а главное, если потребуются иные размеры прямоугольника, достаточно будет изменить только саму функцию `draw_box()`.

==Именование функций==

**Помни**:**** Python — регистрочувствительный язык. Для именования переменных и функций принято использовать стиль lower_case_with_underscores  (слова из маленьких букв с подчеркиваниями).

Поскольку функции **выполняют действия**, большинство программистов предпочитает в именах функций **использовать** **глаголы**. Например:

- функцию, которая **рисует прямоугольник**, можно назвать `draw_box()`;
- функцию, которая **печатает чек**, можно назвать `print_check()`;
- функцию, которая вычисляет заработную плату до удержаний, можно назвать `calculate_gross_рау()`.


==Объявление функции==

Итак, **функция – отдельная, функционально независимая часть программы, выполняющая определенную задачу.**

Функции объявляются с помощью ключевого слова `def` (от англ. define – определять). За ключевым словом `def` следуют название функции, круглые скобки `()` и двоеточие `:`.
```python
def название_функции(): 
	блок кода
```

Первая строка объявления функции называется **заголовком функции**.

Для выделения строк блока кода отступом программисты Python обычно используют **четыре пробела** в соответствии со стандартом PEP 8.
```python
def print_message(): 
	print('Я - Артур,') 
	print('король британцев. ')
```

==Вызов функции==

**Важно:** очень часто начинающие программисты забывают вызывать функцию. Помните, что объявление функции не вызывает ее.

```python
# объявление функции 
def print_message(): 
	print('Я - Артур,') 
	print('король британцев. ') 
	
# вызов функции 
print_message()
```

**Примечание .** Иногда, при объявлении функции требуется сделать своего рода заглушку, чтобы функция ничего не выполняла. Тогда мы используем ключевое слово `pass`:
```python
def do_nothing(): 
	pass
```
Мы объявили функцию с именем `do_nothing()`. Тело такой функции содержит единственную строку кода, которая ничего не делает.



#### 2. Функции с параметрами 

==Функции с параметрами==

Давайте перепишем предыдущую версию функции `draw_box()` так, чтобы она принимала параметры, задающие высоту и ширину прямоугольника:
```python
def draw_box(height, width): # функция принимает два параметра 
	for i in range(height): 
		print('*' * width)
```

Теперь наша функция `draw_box()` принимает два целочисленных параметра `height` – высота прямоугольника и `width` – ширина прямоугольника, и для ее вызова нам нужно обязательно их указать.
```python
draw_box(5, 7)

# Результатом такого вызова функции `draw_box(5, 7)` будет:
******* 
*******
******* 
******* 
*******
```

==Параметры VS аргументы==

**Аргумент** – это любая порция данных, которая передается в функцию, когда функция вызывается. **Параметр** – это переменная, которая получает аргумент, переданный в функцию.

Для функции `draw_box(height, width)`:
```python
​def draw_box(height, width): 
	for i in range(height): 
		print('*' * width)
```
параметрами являются переменные `height` и `width`.

В момент вызова функции `draw_box(height, width)`:
```python
height = 10 
draw_box(height, 9)
```

==Внесение изменений в параметры==

Когда аргумент передается в функцию, параметрическая переменная функции будет ссылаться на значение этого аргумента. Однако любые изменения, которые вносятся в параметрическую переменную, не будут влиять на аргумент.

**Примечание 1.** Функции в Python могут принимать сколько угодно параметров.

**Примечание 2.** Иногда вместо параметров и аргументов говорят о **формальных параметрах** и **фактических параметрах**. Формальные параметры – переменные, которые мы пишем при описании функции. Фактические параметры – то, что реально подставляется при вызове функции.




#### 3. Локальные и глобальные переменные

==Локальные переменные==

**Локальными** называются переменные, объявленные внутри функции и доступные только ей самой. Программный код за пределами функции к ним доступа не имеет.

Рассмотрим следующий программный код:
```python
def print_texas(): 
	birds = 5000 
	print('В Техасе обитает', birds, 'птиц.') 
def print_california(): 
	print('В Калифорнии обитает', 
	birds, 'птиц.')
```

==Область видимости параметрической переменной==

Область видимости параметрической переменной — функция, в которой этот параметр используется. К параметрической переменной имеет доступ весь программный код этой функции.
```python
def draw_box(height, width): 
	for i in range(height): 
		print('*' * width)
```

**Примечание 1.** Параметрическая переменная тоже локальная.

**Примечание 2.** Память для локальных переменных выделяется на время исполнения данной функции в специальной области, называемой [стеком](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA). При завершении работы функции память освобождается, внутренние результаты работы функции не сохраняются от одного обращения к другому.

==Глобальные переменные==

**Глобальными** называются переменные, объявленные в основной программе и доступные как программе, так и всем ее функциям.
```python
birds = 5000 # глобальная переменная 

def print_texas():
	print('В Техасе обитает', birds, 'птиц.') 

def print_california(): 
	print('В Калифорнии обитает', birds, 'птиц.')
```

==Глобальные переменные – зло==

- **Глобальные переменные затрудняют отладку программы.** Значение глобальной переменной может быть изменено любой инструкцией в программном файле. Если обнаружится, что в глобальной переменной хранится неверное значение, то придется отыскать все инструкции, которые к ней обращаются, чтобы определить, откуда поступает плохое значение. В программе с тысячами строк кода сделать это непросто.
- **Функции, использующие глобальные переменные, обычно зависят от этих переменных.** Если возникнет необходимость применить такую функцию в другой программе, скорее всего придется эту функцию перепроектировать, чтобы она не опиралась на глобальную переменную.
- **Глобальные переменные затрудняют понимание программы.** Глобальная переменная может быть модифицирована любой инструкцией в программе. При необходимости разобраться в какой-то части программы, использующей глобальную переменную, придется узнать обо всех других частях программы, обращающихся к этой глобальной переменной.

==Глобальные константы==

Математический модуль `math`  определяет две глобальные переменные, `math.pi` и `math.e`, которым присвоены математические значения констант _[π](https://ru.wikipedia.org/wiki/%D0%9F%D0%B8_(%D1%87%D0%B8%D1%81%D0%BB%D0%BE))_ = `3.14159265` и _[e](https://ru.wikipedia.org/wiki/E_(%D1%87%D0%B8%D1%81%D0%BB%D0%BE))_ = `2.71828`.

==Ключевое слово global==

Если нужно, чтобы инструкция внутри функции присваивала значение глобальной переменной, то требуется дополнительный шаг. В этом случае, глобальная переменная должна быть объявлена внутри функции.
```python
def print_texas(): 
	global birds 
	birds = 5000 
	print('В Техасе обитает', birds, 'птиц.') 
	
def print_california(): 
	print('В Калифорнии обитает', birds, 'птиц.') 
	
print_texas() 
print_california()

#  Результатом выполнения следующего кода:
В Техасе обитает 5000 птиц. 
В Калифорнии обитает 5000 птиц.
```



#### 4. Функции с возвратом значения. Часть 1 

==Функция с возвратом значения==

Функцию с возвратом значения пишут точно так же, как и без, но она должна иметь инструкцию `return`.
```python
def название_функции(): 
	блок кода 
	return выражение
```
Функция с возвратом значения имеет инструкцию `return`, возвращающую значение в ту часть программы, которая ее вызвала.
```python
# функция перевода градусов Фаренгейта в градусы Цельсия 
def convert_to_celsius(temp): 
	result = (5 / 9) * (temp - 32) 
	return result 

# основная программа 
temp = float(input('Bвeдитe количество градусов по Фаренгейту: ')) 
celsius = convert_to_celsius(temp) 
print(celsius) # градусы Цельсия
```
![[Screenshot 2024-10-03 085932.png]]

==Использование инструкции return по максимуму==

```python
def convert_to_celsius(temp): 
	result = (5 / 9) * (temp - 32) 
	return result
```
Эта функция хорошо справляется с поставленной перед ней задачей, но ее можно упростить.
```python
def convert_to_celsius(temp): 
	return (5 / 9) * (temp - 32)
```

==Использование нескольких return==

В одной функции может быть сколько угодно инструкций `return`. Рассмотрим функцию `convert_grade()`, которая переводит стобалльную оценку в пятибалльную:
```python
def convert_grade(grade): 
	if grade >= 90: 
		return 5 
	elif grade >= 80: 
		return 4 
	elif grade >= 70: 
		return 3 
	elif grade >= 60: 
		return 2 
	else: 
		return 1 
	
# основная программа 
grade = int(input('Введите вашу отметку по 100-балльной системе: ')) 
print(convert_grade(grade))
```

**Примечание 1.** Функции с возвратом значения предоставляют те же преимущества, что функции без возврата значения:

- упрощают программный код;
- уменьшают дублирование кода;
- упрощают тестирование кода;
- увеличивают скорость разработки;
- способствуют работе в команде.

**Примечание 2.** Графическая интерпретация работы функции с возвратом значения:
![[Screenshot 2024-10-03 090727.png]]

==Слияние двух отсортированных списков==
Простейшее решение задачи слияния списков использует списочный метод `sort()`:
```python
def merge(list1, list2):     
	result = list1 + list2 # создаем результирующий список     
	result.sort() # сортируем список встроенным методом sort()     
	return result # возвращаем отсортированный список 
	
list1 = [3, 10, 11, 12, 47, 57, 58, 63, 77, 79, 80, 95] 
list2 = [0, 11, 12, 20, 24, 26, 47, 48, 53, 65, 70, 81, 84, 84, 90] 
list3 = merge(list1, list2) # вызываем функцию слияния двух отсортированных списков 

print(list3)
```


==Быстрое слияние двух отсортированных списков в один==

Алгоритм быстрого слияния следующий:

1. Создаем численные указатели `p1 = 0` и `p2 = 0` на начала обоих списков `list1` и `list2` соответственно;
2. На каждом шаге берем меньший из двух элементов `list1[p1]` и `list2[p2]`;
3. Записываем его в результирующий список; 
4. Увеличиваем на 11 указатель на первый элемент списка (`p1` или `p2`), из которого был взят элемент;
5. Когда один из начальных списков закончился, добавляем все оставшиеся элементы второго списка в результирующий список.

Следующий программный код:
```python
def quick_merge(list1, list2): 
	result = [] 
	
	p1 = 0 # указатель на первый элемент списка list1 
	p2 = 0 # указатель на первый элемент списка list2 
	
	while p1 < len(list1) and p2 < len(list2): # пока не закончился какой-нибудь из списков 
		if list1[p1] <= list2[p2]: 
			result.append(list1[p1]) 
			p1 += 1 
		else: 
			result.append(list2[p2]) 
			p2 += 1 
			
	if p1 < len(list1): # прицепление остатка 
		result += list1[p1:] 
	else: # иначе прицепляем остаток другого списка 
		result += list2[p2:] 
	
	return result
```
Вот пример:
```python
list1 = [3, 10, 11, 12, 47, 57, 58, 63, 77, 79, 80, 95] 
list2 = [0, 11, 12, 20, 24, 26, 47, 48, 53, 65, 70, 81, 84, 84, 90] 
list3 = quick_merge(list1, list2) 

print(list3)

# выведет:
[0, 3, 10, 11, 11, 12, 12, 20, 24, 26, 47, 47, 48, 53, 57, 58, 63, 65, 70, 77, 79, 80, 81, 84, 84, 90, 95]
```



#### 5. Функции с возвратом значения. Часть 2

==Возвращение булевых значений==

Python позволяет писать [булевы функции](https://ru.wikipedia.org/wiki/%D0%91%D1%83%D0%BB%D0%B5%D0%B2%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F), возвращающие либо истину (`True`), либо ложь (`False`). Булеву функцию можно применять для проверки условия, тогда значения True и False будут сигнализировать о его выполнении.

Это можно сделать так:
```python
number = int(input()) 
if number % 2 == 0: 
	print('Это число четное. ') 
else: 
	print('Это число нечетное.')
```
Этот фрагмент кода будет легче понять, если написать булеву функцию `is_even()`, которая принимает число в качестве аргумента и возвращает `True`, если оно четное, и `False` если нечетное.
```python
def is_even(number): 
	if number % 2 == 0: 
		return True 
	else: 
		return False
```


==Использование булевых функций для валидации входных данных==

Булевы функции можно также использовать для _**упрощения сложного кода валидации входных данных**_. Например в программе, предлагающей пользователю ввести номер модели изделия, где возможны только значения 100100, 200200 или 300300, можем написать такой код:
```python
model = int(input()) 

while model != 100 and model != 200 and model != 300: 
	print('Допустимыми номерами моделей являются 100, 200 или 300.') 
	model = int(input())
```




















#### 6. Функции с возвратом значения. Часть 3 

==Функции с возвратом нескольких значений==

В Python функции не ограничены возвратом всего одного значения. После инструкции `return` можно определить много выражений, разделенных запятыми:
```python
return выражение 1, выражение 2, выражение 3 ...
```

Возвращающие несколько значений функции – исключительная особенность языка Python. В большинстве языков программирования для возврата нескольких значений используется результирующий тип данных – список, который может содержать несколько значений.

==Преимущества использования функций==

<font color="#00b0f0">Разбивая программы на функции получаем:</font>

- **Более простой код.** Разбитый на функции код программы проще и легче для понимания.  Несколько небольших функций намного легче читать, чем одну длинную последовательность инструкций;
- **Повторное использование кода.** Функции позволяют избежать многократного повторения кода в программе. Если какая-то операция в программе выполняется в нескольких местах, то можно один раз написать для нее функцию и затем исполнять ее, когда понадобится.
- **Более простое тестирование.**  Когда каждая задача в программе содержится в собственной функции, программисты могут индивидуально протестировать каждую функцию и определить, выполняет ли она свою задачу правильно.
- **Более быстрая разработка.** Предположим, что программист или команда программистов разрабатывает много программ. Они обнаруживают общие задачи у разных программ, например выяснение имени пользователя и пароля, вывод текущего времени. Каждый раз писать программный код для этих задач не имеет смысла. Для часто встречающихся задач пишут функции, и включают в состав любой нуждающейся в них программы.
- **Упрощение командной работы.** Когда программа разрабатывается как набор функций, разным программистам можно поручить написание отдельных функций.

==Что выделять в функции?==

<font color="#00b0f0">В функцию можно выделить любой законченный фрагмент программы. Можно ориентироваться на рекомендации:</font>

- Когда несколько раз пишете в программе одну и ту же последовательность команд, необходимость введения функции приобретает характер острой внутренней потребности;
- Иногда обилие мелочей заслоняет главное и полезно убрать в функцию подробности, скрывающие смысл основной программы;
- Полезно разбить длинную программу на составные части, как книгу разбивают на главы, при этом основная программа становится похожей на оглавление;
- Сложные частные алгоритмы бывает полезно отладить отдельно в небольших тестирующих программах. Включить их в основную программу будет легко, если они оформлены в виде функций. Например, функций сортировок;
- Сделанное хорошо в одной программе, хочется перенести в новые. Для повторного использования лучше сразу выделять в программе полезные алгоритмы в отдельные функции, а функции собирать в пакеты.


## Работа над мини-проектами и заключение


[[#1. Модуль рандом]]
[[#2. Заключение]]
[[#3. Веб сайты с задачами по программированию 🐍]]


#### 1. Модуль рандом

==Случайные числа   /    Модуль random==

Для использования этих функций в начале программы необходимо подключить модуль, что делается командой **import**:
```python
import random
```

==Функция randint()==

Функция `randint()` принимает два обязательных аргумента `a` и `b` и возвращает случайное целое число из отрезка [a;b].

Следующий код выводит два случайных целых числа: `num1` из отрезка `[0; 17]` и `num2` из отрезка `[-5; 5]` .
```python
import random 

num1 = random.randint(0, 17) 
num2 = random.randint(-5, 5) 

print(num1) 
print(num2)
```

**Важно:** левая и правая граница `a` и `b` включаются в диапазон генерируемых случайных чисел. Результатом вызова функции `random.randint(2, 9)` может быть любое число от 22 до 99 включительно.

Следующий код выводит 1010 случайных целых чисел из диапазона [1;100][1;100]:

```python
import random

for _ in range(10):
    print(random.randint(1, 100))
```

Среди этих чисел возможны повторения, поскольку каждый раз выбирается случайное.

==Функция randrange()==

Следующий код присваивает переменной `num` случайное число в диапазоне от 00 до 99:
```python
import random 
num = random.randrange(10)
```

Следующий код задает начальное значение и конечный предел последовательности:
```python
import random 
num = random.randrange(5, 10)
```

==Функция random()==

Следующий код выводит случайное число с плавающей точкой из диапазона [0.0;1.0)
```python
import random 
num = random.random() 
print(num)
```

==Функция uniform()==

Функция `uniform()` тоже возвращает случайное число с плавающей точкой, но при этом она позволяет задавать диапазон для отбора значений.
```python
import random 
num = random.uniform(1.5, 17.3) 
print(num)
```

==Начальные значения случайного числа==

Вместе с тем, могут иметься некоторые программы, где требуется всегда генерировать одну и ту же последовательность случайных чисел. При необходимости для этого можно вызвать функцию `seed()`, задав начальное значение
```python
import random 
random.seed(17) # явно устанавливаем начальное значение для генератора случайных чисел 
for _ in range(10): 
	print(random.randint(1, 100))

# Результатом выполнения такого кода может быть:
67 
54 
39 
47 
38 
23 
99 
91 
91 
70
```


**Примечание 1.** Подключение модуля следующим образом:
```python
from random import *
```
позволяет в дальнейшем не писать название модуля и символ точки при вызове функций модуля.

**Примечание 3.** Функция `randint()` реализована на основе функции `randrange()` следующим образом:
```python
# Return random integer in range [a, b], including both end points.
def randint(self, a, b):
    return self.randrange(a, b + 1)
```

==Функция shuffle()==

Функция `shuffle()` принимает список в качестве обязательного аргумента и перемешивает его случайным образом.
```python
import random 
numbers = [1, 2, 3, 4, 5, 6, 7, 8] 
random.shuffle(numbers) 
print(numbers)

# Результатом работы такого кода может быть:
[4, 7, 8, 1, 2, 3, 6, 5]
```


==Функция choice()==

Функция `choice()` принимает список (строку) в качестве обязательного аргумента и возвращает **один** случайный элемент из переданного списка (строки).
```python
import random 
print(random.choice('BEEGEEK')) 
print(random.choice([1, 2, 3, 4])) 
print(random.choice(['a', 'b', 'c', 'd']))

# Результатом работы такого кода может быть:
E 
3 
c
```

==Функция sample()==
Функция `sample()` принимает два обязательных аргумента: список (строку) и количество случайных элементов, а возвращает список случайных элементов в указанном количестве.
```python
import random 
numbers = [2, 5, 8, 9, 12] 
print(random.sample(numbers, 1)) 
print(random.sample(numbers, 2)) 
print(random.sample(numbers, 3)) 
print(random.sample(numbers, 5))

# может быть:
[9] 
[12, 5] 
[9, 2, 8] 
[12, 8, 9, 5, 2]
```

**Примечание.** Подробнее о модуле `random` можно почитать [тут](https://docs.python.org/3/library/random.html#).


#### 2. Заключение

==Полезные ссылки 🐍==

1. [Документация Python](https://docs.python.org/3/) чрезвычайно подробна и наполнена большим количеством примеров.
2. Все Python-программисты стараются следовать советам по стилю кода PEP 8, описанным в [документе](https://www.python.org/dev/peps/pep-0008/).
3. Библиотеки, написанные сообществом, находятся на ресурсе [PyPI (Python Package Index)](https://pypi.python.org/pypi). Именно с этого ресурса будут устанавливаться внешние пакеты, когда вы будете устанавливать их с помощью утилиты `pip`.
4. На GitHub есть [коллекция хороших библиотек](https://github.com/vinta/awesome-python) для решения различных задач.
5. [Канал](https://www.youtube.com/channel/UCQfwKTJdCmiA6cXAY0PNRJw) Тимофея Хирьянова на youtube.

#### 3. Веб сайты с задачами по программированию 🐍

1. [Pythonworld](https://pythonworld.ru/samouchitel-python);
2. [Metanit](https://metanit.com/python/tutorial/);
3. [Pythontutor](https://pythontutor.ru/);
4. [Informatics](https://informatics.mccme.ru/);
5. [acmp.ru](https://acmp.ru/);
6. [codeforces.com](https://codeforces.com/);
7. [hackerrank](https://www.hackerrank.com/dashboard).

