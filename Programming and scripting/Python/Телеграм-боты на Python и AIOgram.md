Ссылка на редактор кода -  [https://jsoneditoronline.org/](https://jsoneditoronline.org/)


## Типизированный Python для профессиональной разработки

Вот ссылка на урок - https://www.youtube.com/watch?v=dKxiHlZvULQ

И так же вот книга - ![[Типизированный_Python_для_профессиональной_разработки.pdf]]
#### Type hinting - Зачем ?

Язык Python это язык с динамической типизацией. Это когда переменная в какой то момент может иметь тип строки, в другой момент тип листом и т.д

==Зачем это нужно==

- Раннее выявление ошибок 
Тестирование может показать наличие дефектов в программе, но не доказать их отсуствие




## Общая информация о курсе 


[[#Глоссарий]]


#### Глоссарий

==Определения:==

**Бот** - специальный аккаунт Телеграм, управление которым осуществляется с помощью запросов к [Telegram Bot API](https://core.telegram.org/bots/api). Часто ботом называют не только такой аккаунт, но и пользовательский код (бэкэнд), управляющий этим аккаунтом. Нужно понимать такое разделение, потому что, в зависимости от контекста, термин "бот" может означать либо только аккаунт, либо только бэкэнд, либо всю связку аккаунт-бэкэнд.

**Бэкэнд бота** - программа, которую пишет и запускает разработчик, чтобы управлять ботом. Часто когда говорят "бот" - подразумевают не только специальный аккаунт телеграм, но и его бэкэнд, то есть программно записанную логику взаимодействия бота с пользователями. Но иногда важно различать бота и его бэкэнд.

**Клиент** - приложение телеграм на вашем устройстве (компьютере, телефоне и т.п.), то есть та "прослойка", с помощью которой вы получаете доступ к серверам Телеграм.

**API** - Application Programming Interface (программный интерфейс приложения) - набор правил взаимодействия с каким-либо сервисом с помощью программных запросов. По сути, это описание как можно обратиться к сервису и какие ответы от него получить, без необходимости разбираться как именно сервис работает "под капотом". В контексте написания телеграм-ботов, имеется в виду [Telegram Bot API](https://core.telegram.org/bots/api).

**Callback** - "обратный вызов" - это функция, которая передается в диспетчер (роутер), чтобы быть вызванной при наступлении соответствующих условий. То есть, если апдейт прошел соответствующий фильтр - вызывается callback-функция.

**Callback Query** - апдейт, который приходит боту, если пользователь нажал на инлайн-кнопку.

**Deep-link** - "глубокая ссылка" - ссылка вида **https://t.me/my_bot?start=some_data**, по которой пользователь может перейти в чат с телеграм-ботом. В чате, после перехода по ссылке, появится кнопка START, при нажатии на которую бот получит не только команду /start, но и данные `some_data`. Бывает полезно, если нужно отследить откуда пришел пользователь или для реферальной программы.

**Deploy** - "развертывание" - запуск бота на удаленном сервере для бесперебойной работы.

**Dispatcher** - "диспетчер" - специальный объект `aiogram`, корневой роутер, который занимается получением апдейтов от серверов Telegram, распаковывает их и передает в соответствующие хэндлеры (обработчики).

**Filter** - "фильтр" - шаблон, которому должен соответствовать апдейт или его часть, чтобы сработал отвечающий за него хэндлер. То есть когда боту приходит апдейт, диспетчер пытается последовательно пропустить его через фильтры и, как только объект проходит первый фильтр - срабатывает хэндлер, настроенный на обработку апдейта, прошедшего этот фильтр.

**FSM (Finite State Machine)** - "машина состояний" - конечный автомат, который позволяет хранить состояние пользователя бота, чтобы в зависимости от этого состояния и действий пользователя, переводить пользователя в другие состояния.

**Handler** - "обработчик" - функция, которая обрабатывает апдейт. В идеале, одна функция на каждый тип апдейтов с одинаковым или близким содержимым. Делать большую функцию, где проверять свойства апдейтов с помощью `if...else` - это, чаще всего, плохая практика.

**Inline-кнопка** - "инлайн-кнопка" - кнопка, которая прикрепляется к отправляемому сообщению и может быть отправлена только как часть этого сообщения, в отличие от "обычных" кнопок, которые заменяют стандартную пользовательскую клавиатуру и не прикреплены к какому-либо сообщению бота. При этом хочу уточнить, что говоря "не прикреплены" я имею в виду "не прикреплены визуально", потому что клавиатура с обычными кнопками тоже не может жить сама по себе без сообщения. Удаляя сообщение, с которым была отправлена обычная клавиатура, вы также удалите эту клавиатуру.

**Inline-режим (inline-mode)** - "инлайн-режим" - режим взаимодействия пользователя с ботом через поле ввода сообщения, без прямой отправки сообщения боту. Пользователь вводит в любом чате "@имя_бота," а затем запрос. Бот сразу получает апдейты, не дожидаясь пока пользователь полностью введет сообщение.

**Long polling** - "долгий опрос" - способ взаимодействия бота с сервером Telegram, путем постоянного опроса сервера на предмет наличия апдейтов, но с таймаутом до разрыва соединения. То есть, бот ждет ответа от сервера какое-то время, не разрывая соединения. Если за это время апдейтов нет - сервер сообщает, что апдейтов нет и разрывает соединение. Боту нужно снова посылать запрос на сервер. А если апдейты есть, то сервер их боту отправляет сразу, и сразу же закрывает соединение, не дожидаясь его окончания по таймауту.

**Middleware** - "промежуточное программное обеспечение" - специальная программа, которая является прослойкой между другими программами, передавая информацию от одной к другой. В контексте aiogram - это код, который предназначен что-то сделать с апдейтами до того, как они попадут в хэндлеры, а также, в некоторых случаях, и после обработки апдейтов хэндлерами.

**Polling** - "опрос" - способ получения апдейтов ботом от серверов Telegram, путем постоянного опроса этих серверов на наличие обновлений. В отличие от лонг поллинга, сервер отвечает сразу, независимо от того, есть апдейты или нет. Если они есть - сервер пересылает их боту, а если нет - отвечает, что апдейтов нет.

**Router** - специальный объект aiogram, отвечающий за распределение апдейтов по хэндлерам. В частности, диспетчер - это корневой роутер, от которого могут ответвляться другие роутеры.

**Throttling** - "удушение" - ограничение количества запросов пользователям. Если от пользователя приходит слишком много бессмысленных апдейтов, которые нагружают систему, имеет смысл не передавать их обработчикам, а просто отсекать.

**Token** - "токен" - специальный ключ-идентификатор, по которому сервера Telegram идентифицируют бота. Имея этот ключ, можно управлять ботом, даже не являясь его владельцем, поэтому токен нужно хранить в защищенном месте и никому, без особой необходимости, не передавать. Владелец бота (именно как специального аккаунта в Telegram) может в любой момент перевыпустить токен.

**Update** - "апдейт" - сообщение от сервера Telegram, которое получает бот. Но не только текстовое сообщение, которое пользователь отправил в чат, а вообще любое событие, поддерживаемое Telegram Bot API. Полный список возможных апдейтов можно посмотреть в [документации](https://core.telegram.org/bots/api#update).

**Username** - в рамках Telegram - это уникальное имя бота или пользователя, с помощью которого можно получить доступ к чату с ним (например, **@my_bot**, **@kmsint** внутри приложения Telegram и **https://t.me/my_bot**, **https://t.me/kmsint** из внешних источников).

**Webhook** - способ доставки апдейтов боту, при котором не бот постоянно опрашивает серверы Telegram на наличие новых сообщений (апдейтов), а сервер Telegram пересылает все новые апдейты на специальный URL-адрес, когда эти апдейты есть.


## Общее сведение о телеграм-ботах


[[#1. Как боты устроены ?]]
[[#2. Как создать телеграм-бота]]
[[#3. Как настроить телеграм-бота]]



==Примеры телеграм-ботов==

1. **Searchee Bot** - [@SearcheeBot](https://t.me/SearcheeBot). Бот для поиска телеграм-каналов по тематикам. В принципе, неплохо работает. Лучше, чем поиск в самом телеграме.
2. **InMind** - [@InMindBot](https://t.me/InMindBot). Бот, помогающий учить новые английские слова. Мне нравится.
3. **YolkoBot** - [@yolko_bot](https://t.me/yolko_bot). Бот, в котором можно поделиться фотографией своей Новогодней ёлки, а также посмотреть случайные ёлки от случайных пользователей (я написал его несколько лет назад еще на `aiogram` 2).
4. **Kandinsky bot** - [@kandinsky21_bot](https://t.me/kandinsky21_bot). Бот, который помогает генерировать изображения и видео с помощью нейросетей. У бота довольно неплохой функционал. Можно задавать стили, смешивать картинки, получать вариации картинок и т.п.
5. **Криптобот** - [@CryptoBitBot](https://t.me/CryptoBitBot). Бот, который показывает цену некоторых криптовалют, а также присылает графики.
6. **FinderMusic** - [@fmusbot](https://t.me/fmusbot). Бот для поиска музыкальных треков. В целом, неплох, много доступной музыки.
7. **Habr Random Coffee** - [@RandomCoffee_Habr_bot](https://t.me/RandomCoffee_Habr_bot). Бот, организующий встречи со случайными участниками Хабр-сообщества. Я с помощью бота познакомился с несколькими довольно интересными людьми.
8. **voices of strangers** - [@VoicesOfStrangers_bot](https://t.me/VoicesOfStrangers_bot). Странный и забавный бот, в котором можно послушать аудиосообщения от анонимных незнакомых людей, а также отправить свои.

#### 1. Как боты устроены ?

==Весь цикл взаимодействия==

![[Screenshot 2024-10-14 080902.png]]
Есть две основные технологии, которыми бот может получать то, что ему предназначено от сервера. **Long polling** и **Webhook**. Суть лонг поллинга состоит в том, чтобы постоянно опрашивать сервер на наличие обновлений (апдейтов), предназначенных боту, типа, "Есть, там, чего для меня?". А webhook - это когда сам сервер "стучится" к боту и говорит: "Тебе что-то пришло!",

![[Screenshot 2024-10-14 081819.png]]

==Техника "Спроси утенка" 🦆==

#### 2. Как создать телеграм-бота

Итак, у вас установлен Telegram и есть аккаунт. Отлично! Заходим в поиск и набираем "BotFather". Найдется несколько похожих, но нам нужен официальный - с синей галочкой. Ну, или, вот, вам ссылка - [@BotFather](https://t.me/BotFather).

**Примечание.** Чтобы на любом этапе взаимодействия с [@BotFather](https://t.me/BotFather) получить от него список доступных команд - просто отправьте в чат с ним команды /start или /help.

#### 3. Как настроить телеграм-бота

<font color="#00b0f0">/setname</font> - позволяет менять название бота (не username, который уникален в рамках всего Telegram, а именно имя, которое отображается).

<font color="#00b0f0">/setdescription</font> - команда, позволяющая настроить описание бота, которое увидит пользователь, когда впервые найдет бота в поиске или перейдет к нему по ссылке. То есть перед запуском бота.

<font color="#00b0f0">/setabouttext</font> - эта команда добавляет или изменяет описание в профиле бота.

<font color="#00b0f0">/setuserpic</font> - команда для того, чтобы у бота в профиле появилась картинка (аватар, юзерпик).

<font color="#00b0f0">/setcommands</font> - служит для создания списка команд. У вашего бота появится такая-же синяя кнопка Menu, как на скриншоте у BotFather, при нажатии на которую будет открываться список команд. Если отправить вместо списка команд команду /empty - список команд либо останется пустым, либо станет пустым (если в нем уже были ваши команды).

<font color="#00b0f0">/deletebot</font> - служит для удаления ваших ботов, которые больше не нужны. После ввода этой команды и выбора бота, которого требуется удалить, Телеграм еще раз спросит подтверждаете ли вы это действие и, если вы реально уверены, что пора избавиться от ненужного бота, вам надо будет ввести фразу-подтверждение, после чего бот будет окончательно удален.

<font color="#00b0f0">/token</font> - команда, позволяющая получить токен для вашего бота. Если вы его, вдруг забыли или потеряли. При этом BotFather отправит вам старый токен, а не создаст новый, в отличие от команды <font color="#00b0f0">/revoke</font>, которая позволяет отозвать старый токен и сгенерировать новый.

<font color="#00b0f0">/revoke</font> - команда, позволяющая отозвать текущий токен вашего бота и сгенерировать новый. Новый токен может понадобиться, если старый, по какой-то причине, скомпрометирован. Часто бывает, что при хранении кода бота, например, на гитхабе, по неопытности, пользователи отправляют туда и конфигурационный файл с токеном. И если проект при этом не приватный - токен становится виден всем и кто-нибудь может перехватить управление вашим ботом. До того момента, пока вы не отзовете старый токен, сгенерировав новый.

<font color="#00b0f0">/setinline</font>- команда, включающая inline-режим для бота.
<font color="#00b0f0">Inline-режим</font> позволяет использовать бота, как помощника для поиска информации, в каком чате вы бы не находились. То есть, допустим, вы общаетесь с кем-то и вспомнили, что смотрели какой-нибудь классный видос на ютубе и захотели им поделиться. Конечно, вы можете открыть ютуб, в поиске найти нужное видео, скопировать ссылку, вернуться к чату и отправить эту ссылку собеседнику. Но можно сделать и по-другому. Просто, находясь в чате с нужным собеседником набираете "**@vid предположительное название видео**" и появляется сразу список возможных видео, которые вы можете отправить в чат. Иногда бывает очень удобно! Вы можете настроить и своего бота так, чтобы он помогал вам искать информацию, не выходя из телеграм.
- [@vid](https://t.me/vid) – поиск видео
- [@gif](https://t.me/gif) – поиск GIF
- [@wiki](https://t.me/wiki) – поиск статей в Википедии
- [@pic](https://t.me/pic) – поиск изображений от Яндекс
- [@bold](https://t.me/bold) – форматирование текста

Некоторые боты могут в инлайн-режиме запрашивать у пользователей их геопозицию, чтобы, например, порекомендовать какое-нибудь место поблизости, или выдать задание для квеста на местности, или найти рядом других пользователей бота и т.д. То есть, каждый раз, когда вы набираете "@имя_бота" в любом чате, бот будет спрашивать разрешение на отправку геопозиции, а потом подгружать результаты, от нее зависящие. Чтобы добавить такой функционал - необходимо отправить команду Отцу ботов - <font color="#00b0f0">/setinlinegeo</font>. При этом инлайн-режим уже должен быть у бота включен.

<font color="#00b0f0">/setinlinefeedback</font> - команда, которая позволяет включить сбор статистики, то есть бот будет получать апдейты о выбранных результатах пользователями в инлайн-режиме работы бота.

<font color="#00b0f0">/setjoingroups</font> - команда для настройки разрешения приглашать бота в группы. Если у бота статус "ENABLED" - бота можно приглашать в группы как участника, а если "DISABLED" - нельзя, то есть при попытке добавить бота в группу вы получите такое сообщение:

<font color="#00b0f0">/setprivacy</font> - команда для настройки того, все ли сообщения будет бот видеть в группах. Если статус "ENABLED" - бот будет "видеть" только адресованные ему сообщения:
- которые начинаются как команды, т.е. с символа "/",
- c прямым упоминанием юзернейма бота,
- ответы на сообщения бота, ответы на ответы и так далее.


## Git и GitHUB


[[#1. Git - система контроля версий]]

#### 1. Git - система контроля версий

==Git==

1. [Git: курс](https://www.youtube.com/playlist?list=PLDyvV36pndZFHXjXuwA_NywNrVQO0aQqb) - наверное, самый лучший курс по Git на YouTube, сделанный Ильей Кантором (известным своим учебником по JavaScript - [learn.javascript.ru](https://learn.javascript.ru/)). В коротких 50 роликах объяснение Git от А до Я.
2. [Git. Большой практический выпуск](https://youtu.be/SEvR78OhGtw) - ролик на YouTube от Артема Матяшова с подробным объяснением зачем, почему, для чего и как
3. [GIT - Полный Курс Git и GitHub Для Начинающих [4 ЧАСА]](https://youtu.be/O00FTZDxD0o) - еще одно большое подробное объяснение про Git и GitHub на YouTube
4. [Git и GitHub Курс Для Новичков](https://youtu.be/zZBiln_2FhM) - ну, и чтобы было из чего выбрать - ролик от Владилена Минина. Тоже хороший вход в систему контроля версий Git.
5. [Git для новичков](https://habr.com/ru/post/541258/) - для тех, кто не любит видео, а любит статьи на Хабре
6. [Введение в Git](https://ru.hexlet.io/courses/intro_to_git) - хороший бесплатный курс с практикой от Хекслет
7. [Небольшая шпаргалка по основным командам Git](https://training.github.com/downloads/ru/github-git-cheat-sheet/)
8. [Pro Git](https://git-scm.com/book/ru/v2) - подробная электронная книга про Git

==Как работает Git==

Согласно идеологии Git, файлы в проекте, где есть репозиторий Git могут быть:

1. Неотслеживаемыми (Untracked)
2. Отслеживаемыми

**Неотслеживаемые** файлы - это те, которые есть в директории проекта, но которые еще не добавлены в репозиторий, то есть Git их видит, сообщает о том, что они есть в проекте, но не хранит их в репозитории и не следит за их изменениями. Если мы скопируем репозиторий, чтобы перенести, например, на другой компьютер, этих файлов там не будет.

Среди неотслеживаемых, наверное, можно выделить еще один подкласс файлов - игнорируемые - это те файлы, о которых мы сообщили гиту, что их не надо отслеживать в принципе. Названия таких файлов или шаблоны названий прописываются в специальном файле `.gitignore`, которому будет посвящен отдельный шаг чуть дальше.

**Отслеживаемые файлы** - это те, которые находятся под версионным контролем, то есть те, о которых Git знает, и за изменениями в которых следит. Они могут находиться в трех состояниях:

1. Неизмененные (Unmodified)
2. Измененные (Modified)
3. Подготовленные к коммиту (Staged)

**Примечание 1.** Чтобы получить справку по **Git** прямо в терминале - можно набрать команду `git --help` или, что одно и то же, `git -h`. Чтобы получить справку по конкретной команде **Git** - можно выполнить команду:

```bash
git -h <команда>
```

**Примечание 2.** Если опция к команде может быть записана без пробелов, кавычки ставить не обязательно. То есть, в нашем случае, когда мы в глобальные настройки пользователя добавляли **email** - можно было кавычки не писать и команда

```bash
git config --global user.email "kms101@yandex.ru"
```
равнозначна команде
```bash
git config --global user.email kms101@yandex.ru
```

**Примечание 3.** Глобальные настройки - это настройки в рамках одного пользователя в операционной системе. То есть если компьютером пользуются несколько пользователей с разными учетными записями - у каждого пользователя могут быть свои глобальные настройки, которые не будут пересекаться. Также в Git могут быть системные (`--system`) и локальные (`--local`) настройки. Системные настройки - это настройки в масштабах всей операционной системы, а локальные - в масштабах одного проекта.

**Примечание 4.** Команда `git config --list` выводит все настройки из конфигов всех уровней. Если же надо посмотреть настройки какого-то определенного уровня, то к команде добавляется один из флагов (`--system`, `--global`, `--local`), например, чтобы посмотреть глобальные настройки, команда будет:

**Примечание 5.** Чтобы посмотреть сразу все настройки и где они хранятся - можно выполнить команду:

```bash
git config --list --show-origin
```

==Коммиты==

Чтобы посмотреть в каком сейчас состоянии у нас файлы в проекте с точки зрения **Git** - нужно выполнить команду:
```bash
git status
```

Итак, файлы виртуального окружения и служебные файлы **VS Code** отслеживать нет необходимости, нужные проекту зависимости хранят в файле `requirements.txt`, про который мы обязательно вспомним, когда будем разворачивать бота на удаленном сервере. Поэтому, на текущий момент у нас есть только один файл для отслеживания - это `main.py`. Давайте добавим его в индекс. Для этого выполним команду:
```bash
git add main.py
```

Если какой-либо файл нужно удалить из индекса - можно выполнить команду:
```bash
git rm --cached <файл>
```

 Закоммитим текущее состояние файла командой:
```bash
git commit -m "Это наш первый коммит в проекте"
```

Обратите внимание на число **17368ea** в сообщении, которое появилось после того, как мы создали первый коммит. Это именно число, правда, в 16-ричной системе счисления. Это часть идентификатора коммита, по которому можно посмотреть что это за коммит. Если выполнить команду (не забудьте только указать номер вашего, а не моего коммита):
```bash
git show 17368ea
```

**Примечание 1.** Если в индекс нужно добавить все неотслеживаемые и модифицированные файлы проекта, то можно пользоваться командой:
```bash
git add .
```

**Примечание 2.** Если закоммитить надо не весь индекс, а только некоторые файлы, например, чтобы разбить выполненную работу на несколько разных коммитов, можно выполнить команду:
```bash
git commit -m <файл_1> <файл_2> <файл_3> "Комментарий к коммиту"
```

**Примечание 3.** После добавления файлов в индекс - закоммитятся они именно в состоянии, в котором были добавлены в индекс. То есть, если вы добавили файл в индекс, а потом продолжили работать с ним - в индексе будет версия файла, которая была на момент добавления в индекс. Когда вы закоммитите файл из индекса - `git status` покажет, что в этом файле снова есть изменения и его опять можно добавить в индекс.

**Примечание 4.** Флаг `-m` во время коммита говорит о том, что не нужно открывать текстовый редактор для написания комментария, а можно взять его сразу из опций команды (мы его записывали в кавычках). Если этот флаг не указать, то откроется текстовый редактор, в котором нужно будет написать комментарий к коммиту.

**Примечание 5.** Если вы хотите добавить в индекс все изменения и сразу их закоммитить, то можно использовать не две команды `git add .` и `git commit -m "Комментарий к коммиту"`, а одну, являющуюся их объединением:

```bash
git commit -am "Комментарий к коммиту"
```

==Файл .gitignore==

Как вы могли догадаться, достаточно создать в корне проекта этот самый файл `.gitignore` и добавить в него названия папок - каждое с новой строки.
![[Screenshot 2024-10-16 095106.png]]

## Аннотация типов


[[#1. Type hinting]]

#### 1. Type hinting

==Аннотация типов==

Давайте на конкретном примере. Пусть у нас есть функция, которая принимает число и строку, а возвращает переданную строку, первая буква которой в верхнем регистре, умноженную на число:
```python
def say_something(number, word):
    word = word.capitalize()
    return word * number
```

А, вот, если мы функцию проаннотируем, то IDE будет на лету подсказывать доступные методы. Перепишем функцию с использованием аннотации типов.
```python
def say_something(number: int, word: str) -> str:
    word = word.capitalize()
    return word * number
```
![[Screenshot 2024-10-23 081221.png]]

Синтаксис аннотаций для переменных следующий:
```bash
<имя_переменной>: <тип_переменной> = <значение_переменной>
```
Или без значения переменной:
```bash
<имя_переменной>: <тип_переменной>
```

**Примеры:**
```python
first_var  : int        = 5
second_var : str        = 'second_var'
third_var  : list       = []
fourth_var : float
fifth_var  : dict
sixth_var  : tuple[int] = (1, 2)
```

Синтаксис аннотаций для функций (методов):
```python
def <имя_функции>(<arg_1>: <тип>, <arg_2>: <тип> = <значение>) -> <тип_результата>:
    <тело функции>
```
**Примеры:**
```python
def get_something_1(arg_1: int, arg_2: list[int], arg_3: str = '') -> str:
    pass

def get_something_2(arg_1: tuple[int, bool]) -> None:
    pass
```

==Встроенные типы==

Ко встроенным типам данных относятся:
- int
- float
- str
- bytes
- list
- dict
- set
- frozenset
- ...
Причем, если нужно указать больше одного типа, например, функция может принимать и целые, и вещественные числа, используют символ `|`, обозначающий "или".

**Пример 1.** Функция `some_function` принимает либо целое, либо вещественное число, а возвращает `None`
```python
def some_function(number: int | float) -> None:
    pass
```

**Пример 2.** Функция `get_tuple` принимает список, в котором могут быть вещественные числа и/или булевы значения, а возвращает кортеж целых чисел.
```python
def get_tuple(lst: list[float | bool]) -> tuple[int]:
    return tuple(int(num) for num in lst)
```

**Пример 3.** Функция `do_something` принимает словарь, ключами в котором являются целые числа, а значениями либо строки, либо булевы значения. Возвращает `None`.
```python
def do_something(arg: dict[int, str | bool]) -> None:
    pass
```

==Типы из модуля typing==

Помимо стандартных встроенных типов, для аннотаций можно использовать типы из модуля `typing`. Там много всего - можно подробно изучить в [документации к модулю](https://docs.python.org/3/library/typing.html). Разберем некоторые интересные:
- Any
- Optional
- Union
- Literal

<font color="#00b0f0">Тип Any (использовать, по-возможности, никогда :) )</font>

Бывает так, что указать тип не представляется возможным, потому что точно неизвестно какие данные придут. Тогда используют тип `Any` из модуля `typing`. 
```python
from typing import Any

def func(arg: Any) -> None:
    pass
```

<font color="#00b0f0">Тип Optional</font>

Данный тип подразумевает, что данные могут быть либо какого-то конкретного типа, либо `None`.
```python
from typing import Optional

var_1: Optional[int]
```

<font color="#00b0f0">Тип Union</font>

Как понятно из названия типа - это объединение разных типов. По сути - это другой способ записать, что переменная может быть либо одного, либо другого типа, как мы это делали с помощью символа `|`.
Код:
```python
from typing import Union

var_1: Union[int, float]
var_2: Union[list, tuple, set]
```
эквивалентен коду:
```python
var_1: int | float
var_2: list | tuple | set
```

<font color="#00b0f0">Тип Literal</font>

Используется тогда, когда ожидаются очень конкретные значения (`Literal` - от английского "literally", то есть "буквально"). Например, в качестве ключей словаря могут быть только строки `'name'`, `'second_name'` и `'username'`. Тогда можно записать:
```python
from typing import Literal

user : dict[Literal['name'] | Literal['second_name'] | Literal['username'], str]
```

==Классы и датаклассы==

Но, скажите, вас никогда не напрягали все эти `__init__(self)` и `self.something = something`? Меня напрягали всегда :) И, к счастью, видимо, не меня одного, потому что умные люди придумали датаклассы (dataclasses), которые убирают за "ширму" все эти `__init__(self)`. Смотрите, как лаконично теперь выглядит тот же самый класс `User`
```python
from dataclasses import dataclass

@dataclass
class User:
    user_id: int
    name: str
    age: int
    email: str
```

**Дополнительные материалы по датаклассам:**

1. Статья на Хабре "[Введение в Data classes](https://habr.com/ru/post/415829/)"
2. Статья на Хабре "[9 причин использовать dataclasses в Python](https://habr.com/ru/company/otus/blog/650257/)"

==__annotations__==

О чем еще не сказал, так это о том, где объекты хранят аннотации типов. Для этого существует специальный атрибут `__annotations__`, который хранит аннотации в виде словаря с ключами - названиями переменных и значениями - их типами.

**Пример.** Функция `get_string`, получающая на вход строку и число, а возвращающая строку.
```python
def get_string(string: str, number: int) -> str:
    return string * number
```

Если обратиться к атрибуту `__annotations__` функции `get_string`: 
```python
print(get_string.__annotations__)
```

увидим следующий словарь:
```tex
{'string': <class 'str'>, 'number': <class 'int'>, 'return': <class 'str'>}
```

==Выводы==

**Важная особенность 1:**
Интерпретатор никак не проверяет аннотации типов. То есть код, при котором в функцию будет передан не тот тип данных, что указан в аннотации, может отработать и без ошибок.

**Важная особенность 2:**
Переменные также можно аннотировать, причем необязательно присваивать им значения. Но надо иметь в виду, что присваивать значения переменным в программе нужно до их первого использования, иначе интерпретатор выкинет исключение `NameError`.

**Для аннотаций типов используются:**
1. Встроенные типы данных языка (`int`, `float`, `str`, `list`, `dict`, `tuple`...)
2. Объекты из модуля `typing` (`List`, `Dict`, `NamedTuple`, `Union`, `Optional`, `Any`, `NoReturn`...)
3. Пользовательские классы
4. Классы из сторонних модулей
5. Датаклассы из модуля `dataclasses`

**Примечание.** Аннотации типов хранятся в атрибуте `__annotations__` объектов.

## Что такое API


[[#1. Что такое API?]]
[[#2. Telegram Bot API]]
[[#3. Long polling]]


#### 1. Что такое API?

==Что такое API==

**API (Application Programming Interface)** - "программный интерфейс приложения" - описание правил, по которым одна компьютерная программа может взаимодействовать с другой.

==Примеры API==

1. Сервис [Numbers](http://numbersapi.com/). Интересные факты о числах, годах и датах. API у сервиса открытый, то есть самыми обычными GET-запросами, без регистрации и токенов, можно получать ответы с фактами о числах. Если в адресную строку браузера вбить, например, [http://numbersapi.com/5/math](http://numbersapi.com/5/math), то браузер покажет какой-нибудь из вариантов ответов:

- 5 is the third prime number.
- 5 is the number of Platonic solids.

2.  [Free Currency Exchange Rates API](https://github.com/fawazahmed0/exchange-api). Сервис, с помощью которого можно получать курсы валют по 150+ валютам. Бесплатный, быстрый, не требующий регистрации. Там в README подробно описаны примеры запросов. Например, чтобы получить курс биткоина на текущую дату - надо послать GET-запрос: [https://cdn.jsdelivr.net/npm/@fawazahmed0/currency-api@latest/v1/currencies/btc.json](https://cdn.jsdelivr.net/npm/@fawazahmed0/currency-api@latest/v1/currencies/btc.json)

3.  [Сервис получения кратких новостей](https://github.com/cyberboysumanjay/Inshorts-News-API) по категориям. Например, чтобы получить новости по категории "наука" нужно отправить GET-запрос: [https://inshorts.deta.dev/news?category=science](https://inshorts.deta.dev/news?category=science)

4.  [arXiv API](https://arxiv.org/help/api/user-manual). API для работы с препринтами научных статей.

5.  [Open-Meteo](https://open-meteo.com/en). Сервис получения информации о погоде по координатам.

6. Забавный сервис [yesno.wtf](https://yesno.wtf/), который отправляет случайную гифку со случайным ответом "yes", "no" или "maybe". Например, чтобы получить гифку точно с ответом "yes" - нужно отправить GET-запрос: [https://yesno.wtf/api?force=yes](https://yesno.wtf/api?force=yes)

**Дополнительно:**
- [GitHub-репозиторий](https://github.com/public-apis/public-apis) с большим количеством публичных API
- [Статья на Хабре](https://habr.com/ru/company/macloud/blog/562700/) со списком "интересных (и забавных)" API

==Работа с API с помощью библиотеки requests==

Давайте, в качестве небольшой практики, попробуем поработать с каким-нибудь публичным API. Воспользуемся для этого библиотекой [requests](https://requests.readthedocs.io/en/latest/). Библиотека не входит в список стандартных библиотек Python, поэтому ее сначала нужно установить. Для этого нужно выполнить, находясь в виртуальном окружении (если только вы не хотите поставить библиотеку глобально), команду:
```bash
pip install requests
```
В случае успешной установки, вы увидите что-то типа:

```bash
Successfully installed requests-2.28.1 urllib3-1.26.12
```

Я не буду сейчас подробно останавливаться на функциях и методах библиотеки `requests`, просто покажу, как можно получать информацию с помощью GET-запросов. Давайте выясним где прямо сейчас находится Международная Космическая Станция. 
```python
import requests


api_url = 'http://api.open-notify.org/iss-now.json'

response = requests.get(api_url)  # Отправляем GET-запрос и сохраняем ответ в переменной response

if response.status_code == 200:  # Если код ответа на запрос - 200, то смотрим, что пришло в ответе
    print(response.text)
else:
    print(response.status_code)  # При другом коде ответа выводим этот код
```
Если все получилось, то вы должны увидеть в терминале сообщение вида:
```bash
{"message": "success", "iss_position": {"longitude": "7.6753", "latitude": "50.2226"}, "timestamp": 1668894374}
```

 "longitude" и "latitude" - это, соответственно, долгота и широта текущего положения МКС.

Код ответа 200 говорит об успешном выполнении запроса, соответственно, можно посмотреть, что содержится в атрибуте `text` переменной `response`.


#### 2. Telegram Bot API

==Взаимодействие с Telegram Bot API==

Чтобы взаимодействовать со своими ботами через Telegram Bot API - нужно посылать запросы по следующей форме:
```http
https://api.telegram.org/bot<token>/METHOD_NAME
```
Вместо `<token>` нужно вставить токен вашего бота, а вместо `METHOD_NAME` - имя метода, доступного в [API](https://core.telegram.org/bots/api#available-methods). После `METHOD_NAME` еще можно после вопросительного знака `?` посылать параметры в виде `key1=value1&key2=value2`. Таких пар ключ=значение может быть столько, сколько требуется.

==Автоматизируем запросы к Telegram Bot API==

А вот и первый код:
```python
import requests 
import time 

API_URL = 'https://api.telegram.org/bot' 
BOT_TOKEN = 'Токен нашего Бота' 
TEXT = 'Ура! Классный апдейт!' 
MAX_COUNTER = 100 

offset = -2 
counter = 0 
chat_id: int 

while counter < MAX_COUNTER: 
	
	print('attempt =', counter) #Чтобы видеть в консоли, что код живет 
	updates = requests.get(f'{API_URL}{BOT_TOKEN}/getUpdates?offset={offset + 1}').json() 
	
	if updates['result']: 
		for result in updates['result']: 
			offset = result['update_id'] 
			chat_id = result['message']['from']['id'] 
			requests.get(f'{API_URL}{BOT_TOKEN}/sendMessage?chat_id={chat_id}&text={TEXT}') 
			
	time.sleep(1) 
	counter += 1
```

Теперь некоторые комментарии к коду. Сначала импортируем нужные библиотеки, а затем прописываем значения констант:
```python
import requests
import time


API_URL = 'https://api.telegram.org/bot'
BOT_TOKEN = '5424991242:AAGwomxQz1p46bRi_2m3V7kvJlt5RjK9xr0'
TEXT = 'Ура! Классный апдейт!'
MAX_COUNTER = 100
```
`MAX_COUNTER` - это количество итераций цикла, в котором мы получаем апдейты от сервера. Можете сделать любым, с каким захотите поэкспериментировать.

При запуске на сервере (т.е в браузере), через сслыку - `https://api.telegram.org/bot<token>/METHOD_NAME`
тут можем указать `id` апдейтов через `offset`

==Еще раз о важном==

1. AIOgram - это инструмент, а чем лучше разработчик знает свой инструмент, тем эффективнее может его использовать. Хорошо понять почему инструмент устроен так, а не иначе, помогает понимание предпосылок, определивших его устройство.

Даже хочу привести тут один пример, который наглядно покажет, что структура классов `aiogram` - это почти точная репрезентация типов из API. Возьмем тип `Message` и его описание из документации Telegram Bot API:

2. AIOgram - это "догоняющий" инструмент. Сначала все новые возможности телеграм-ботов появляются в API, а уже потом в библиотеке. И если руки чешутся сразу пробовать что-то новое - работы с документацией к API не избежать.
3. Документация к `aiogram`, к сожалению, не так хороша как документация к Telegram Bot API. И это не очень страшно, потому что, как я уже сказал, классы библиотеки являются репрезентацией методов API. Если вы понимаете, что делает тот или иной метод API - вам будет намного легче разобраться в том, что ожидать от классов и их методов библиотеки.
4. Даже в таких крутых инструментах, как `aiogram`, встречаются ошибки и неожиданное поведение, причем иногда довольно трудно отлавливаемое. Без обращения к документации Telegram Bot API бывает оооочень сложно понять, что вообще происходит.

Поэтому еще раз рекомендую заглядывать в документацию к [Telegram Bot API](https://core.telegram.org/bots/api) - там много полезного!


#### 3. Long polling

==Polling==

