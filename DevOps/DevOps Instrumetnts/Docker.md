Ссылка на Docker, в особенности работы над ним - https://github.com/Lexxx42/Docker-for-beginners-practical-experience/blob/main/1_introduction/2how_to_begin_to_wrork_with_docker.md

Сам сайт Docker - https://www.docker.com/

Установка на Linux - https://docs.docker.com/desktop/install/ubuntu/

В этом разделе размещены подробные мануалы о том, как поставить докер комьюнити едишн на разные платформы- https://hub.docker.com

Изучаем Docker, часть 4: уменьшение размеров образов и ускорение их сборки - https://habr.com/ru/companies/ruvds/articles/440658/

Как устроен процесс создания docker-контейнера (от docker run до runc) - https://habr.com/ru/companies/otus/articles/511414/

Обучение Docker - https://www.youtube.com/watch?v=O8N1lvkIjig&t=95s
## Обзор команд 

Тут список команд для Docker:
```javascript
docker run        / запуск контейнера 
------------------------------------------------------------------------------
docker ps         / список контейнеров 
------------------------------------------------------------------------------
docker ps -a      / весь список контейнеров и запущенных и нет
------------------------------------------------------------------------------
docker stop       / остановка контейнеров 
------------------------------------------------------------------------------
docker rm         / удаление контейнеров 
------------------------------------------------------------------------------
docker images     / список образов 
------------------------------------------------------------------------------
docker rmi        / удаления образов 
------------------------------------------------------------------------------
docker pull       / скачать образ 
------------------------------------------------------------------------------
docker exec       /  для запуска команд работающего докер контейнера
------------------------------------------------------------------------------
dcoker run -d название контейнера / для запуска контейнера в фоновом режиме 
------------------------------------------------------------------------------
docker attach id или имя контейнера / прикрепить контейнер к консоли 
```
## Команды Docker 
Запуск конейнера
```javascript
docker run -it alpine   /   -it что бы войти в контейне
```

Запуск в фоновом режиме 
```javascript
docker run -d alpine sleep 15   /   времы можно ставить любое, это секунды
```

Это команда удалит все контейнеры:
```javascript
docker rm $(docker ps -aq)
```

Это команда удалит все образы:
```javascript
docker rmi -f $(docker images)
```

Для того что бы запустить образ своей версии нужно вот что указать:
```javascript
docker run redis:5.0
```
Здесь мы указываем сам образ плюс `:` и версию которая нам нужна, т.е `tag` в нашем случаи это `5.0`

Что бы запустить контейнер и вывести вывод в терминал нужна команда;
```javascript
docker run -it имя команды
-i / связать стандартный ввод хоста со стандартным вводом контейнера
-t / связать стандартный вывод хоста со стандартным выводом контейнера
```

Передать на ввод контейнеру строку `qwe`
```javascript
echo 'qwe'| docker run -i имя
```

Сопоставить порту 80 хосту порту 5000 в контейнере
```javascript
docker run -p 80:5000 имя 
```

Смонтировать каталог `/opt/datadir/` хоста в каталог `/var/lib/mysql` в контейнере
```javascript
docker run -v /opt/datadir/:/var/lib/mysql имя
```

Детальная информация о контейнере
```javascript
docker inspect имя
```

Вывести стандартный вывод контейнера
```javascript
docker logs -f имя
```

Команда с помощью которой мы сможем посмотреть какой контейнер употребляет больше памяти:
```javascript
docker container stats
```

Для обновления политики перезапуска (restart policy):
```javascript
docker update --restart always <container_name_or_id>
```
Где `<container_name_or_id>` — это имя или ID вашего контейнера Redis.

Проверка драйвера логирования по умолчанию:
```javascript
docker system info
```

Проверка статуса службы `docker` на хосте:
```javascript
sudo systemctl status docker
```

Для работы с удоленным Docker хостом команда:
```javascript
export DOCKER_HOST=ip address
```

Этой командой мы можем удалить неиспользуемые тома:
```javascript
docker volume prune
```

## Особенности контейнеров 
- Контейнеры не преднозначены для размещения операционных систем. Цель работы выполнить работу и перестать тратить ресурсы 
- Контейнер жив пока жив процессор 
- Нельзя сопоставить несколько контейнеров с одним и тем же портом к одному порту на докер-хосте
## Проблемы при работе 
Нет прав на работу, и вот решение: 
```javascript
sudo usermod -aG docker $USER
newgrp docker
sudo systemctl status docker
```
## Образы Docker
==1.Как создается образ==
- OS - Ubuntu                                /     Установка операциооной системы
- Обновить apt репозиторий       /    Обновляем apt репозиторий
- Установить зависимости apt      /    Затем устонавливаем python с соответствующими зависимостями и утилитами 
- Установить зависимости pip      /    Потом с помощью pip создаем framework basis 
- Скопировать код в /opt              /    Осталось скопировать исходный код в нужную папку, например в opt
- Запустить с параметром 'flask'   /    Запускаем код нашего веб сервера 
А вот и команды:
```javascript
FROM ubunutu

RUN apt-get update
RUN apt-get install -y python3 python3-plp

RUN pip3 install flask

COPY app.py /opt/app.py

ENTRYPOINT FLASK_APP=/opt/app.py flask run --host=0.0.0.0 --port=5000
```

Потом создаем свой образ:
```javascript
docker build -t имя 
```
Это создаст локальный Docker образ в нашей системе

Что бы сделать его доступным в публичном docker репозиторий:
```javascript
docker push rotorocloud/webapp
```

**ВНИМАНИЕ:** В конце команды мы используем "." (точку) - символ, который обозначает текущую директорию, поэтому нам нужно запускать эту команду из каталога, в котором находится `Dockerfile`.

==2.Dockerfile==
Теперь посмотрим dockerfile
![[Screenshot 2024-07-26 151408.png]]
Он состоит из инструкций и аргументов 

Все что написано слева заглавными буквами будет считаться #инструкциями 
![[Screenshot 2024-07-26 151915.png]]
Все что справо это #аргументы 

==3.Слои Docker==
Слои в Docker (Docker layers) — это отдельные, неизменяемые файловые системы, которые используются для создания Docker-образов. Каждый слой представляет собой шаг в процессе сборки образа, и они объединяются для создания окончательного образа контейнера.
![[Screenshot 2024-07-26 152437.png]]

==4.Что контенеризируется==
Мы можем создовать контене. версии практически любых приложений от серверных до повседневных приложений
![[Screenshot 2024-07-26 152940.png]]

Контейнер после себя не оставляет мусор как другие системы 

## Создание Docker образа

## Переменные окружения
Начнем с нашего простого приложения показывающего ракеты.
Вот пример:
```python
from flask import Flask
import os

app=Flask(_name_)

...

rocket=os.environ.get('ROCKET_SIZE')

@app.route("/")
def main():
  #return 'Hello'
  print(rocket)
  return render_template('hello.html',name=socket.gethostname(),rocket=rocket)
  if_name_=="_main_":
...


  app.run(host="0.0.0.0",port="8080")
```

А теперь пересоберем Docker образ и запустим
Для запуска ракет в разных размерах вот команды:
```javascript
docker run rotorocloud/simple-webapp-rockets
docekr run -e ROCKET_SIZE=avarage rotorocloud/simple-webapp-rockets
docker run -e ROCKET_SIZE=small rotorocloud/simple-webapp-rockets
docker run -e ROCKET_SIZE=big rotorocloud/simple-webapp-rockets
```

Как узнать какие переменные существуют уже в запущенном контейнере:
```javascript
docker inspect
```

## Аргументы команд и точка входа в Docker 

Посмотрим dockerfile nginx:
![[Screenshot 2024-07-30 100637.png]]
Как мы видим команда по умолчанию стоит: CMD ['nginx']

Как нам указать другую команду при старте контейнера:
```javascript
docker run ubuntu sleep 5
```

Как сделать эти изменения постоянными 
Для этого создадим свой образ из базового образа Ubuntu 
```javascript
FROM Ubuntu

CMD sleep 5
```
А потом запустим образ
```javascript
docker build . -t ubuntu-sleeper
docker run ubuntu sleeper
```

Как изменить этот промежуток не меняя этот образ
```javascript
FROM Ubuntu

ENTRYPOINT ["sleep"]
```
Это с добавлением количества секунд 

А для значени по умолчанию будем использовать
```javascript
FROM Ubuntu

ENTRYPOINT ["sleep"]

CMD ["5"]
```

## Docker Compose 

Ссылка по обучению Docker Compose - https://www.youtube.com/watch?v=0uLDObuutFs

Docker compose команды:
```javascript
docker-compose up -d                  / разворачивает стег из файла docker                                             compose в текущей дириктории
docker-compose down                   / остонавливает стег и удоляет все                                               контейнеры из сети
docker-compose ps                     / покажет контейнеры 
docker-compose logs                   / покажет общий pool логов
docker0compose up -d --scale vote=3   / управление количеством реплик                                                  определенной службы
```

## Yaml
Yaml файл используется для предстовления данных, в нашем случаи для файлов конфигурации:
![[Screenshot 2024-07-30 160242.png]]

Если взять данный в простейшей форме вроде ключ значение, то вот как оно будет выглядеть:
![[Screenshot 2024-07-30 160433.png]]
Перед свойствами отдельного элемента должно быть равное количество пробелов

==Yaml пробелы==
Количество пробелов в данном случаи равны:
![[Screenshot 2024-07-30 160454.png]]

А в этом случаи количество пробелов не равны:
![[Screenshot 2024-07-30 160513.png]]
Такая форма не правельна, тут нет смысла. Так же это выдаст синтаксическую ошибку.

==Dictionary or Lists==
Вот пример `dictionary` на рисунке: тут также использауется dictionary в другом dictionary 
![[Screenshot 2024-07-30 160636.png]]

А вот пример `lists` на рисунке:
![[Screenshot 2024-07-30 160706.png]]
тут так же можно хранить всю информацию в одном yaml файле.

==Особенности Yaml==
![[Screenshot 2024-07-30 160748.png]]

Для Dictionary порядок не важен 
Для Lists порядок имеет значение, должен быть определенный порядок 

## Хранение в Docker

Для удаленного подключения к docker хосту
```javascript
docker -H=remote-docker-engine:host
docker -H=ip address:host run nginx
```

#### Среда выполнения (Cgroup)
Для работы с Docker иногда нужно больше мощности процессора или памяти, для этого мы можем давать больше мощности сами, и вот как это делать:
```javascript
docker run --cpus=.5 nginx
docker run --memory=100m nginx
```

Вот скрипт для запуска конейнеров и проверка их процессора
```javascript
#!/bin/sh
docker run -d --name stress75 --cpuset-cpus 0 --cpu-shares 768 benhall/stress
docker run -d --name stress25 --cpuset-cpus 0 --cpu-shares 256 benhall/stress
sleep 5
docker stats --no-stream
docker rm -f stress75 stress25
```
В отличие от памяти, ограничения CPU основаны на доле совместного времени обработки процесса. Таким образом, можно приоритезировать самые важные процессы, а на не критические выделять CPU по остаточному принципу. Есть несколько способов разделить ресурсы, здесь мы воспользовались инструкцией `--cpu-shares`

Пример ( Первая команда запускает контейнер в обычном режиме изоляции, а вторая в PID-пространстве хоста ):
```javascript
docker run -it alpine ps aux
docker run -it --pid=host alpine ps aux
```

Та же история с процессами, их можно сделать общими. Например, ты можешь залезть в контейнер и исследовать его с помощью `strace`. И тебе не потребуется ставить дополнительное ПО в контейнер, останавливать контейнер и перезапускать приложение в нем.
```javascript
docker run --pid=container:http alpine ps aux
```

#### Хранилище
Здесь мы посмотрим как Docker хранит данные и как он упровляет в фаловыми системи контейнера
Когда мы устонавливаем Docker, он создает некоторую структуру папок 
`/var/lib/docker`
`overlay2`
`container`
`images`
`volumes`

Файлыа связанные с docker контейнерами и docker образом хранятся в `/var/lib/docker`

Эта команда покажет содержимое папки контейнера:
```javascript
sudo ls /var/lib/docker/containers/$(docker ps -aq --no-trunc --filter name=alpine-3)
```

В Docker Engine входят компоненты:
- Docker CLI, Docker Daemon, REST API

==Docker Engine==
- Docker Daemon упровляет образами, контейнерами, томами и сетями
- LibContainer по умолчанию отвечает за управление контейнерами в современных поставках Docker в Linux
- Containerd-Shim отвечает за поддержание контейнеров в живом состоянии, когда Docker Daemon отключается 
- Docker Engine упровляет такими обьектами как Network, Volumes, Images, Container

Тома (Volumes) являются предпочтительным механизмом для организации постоянного хранения для докер-контейнеров


==Этапы запуска контейнера с использованием новой архитектуры docker:==
1. **Docker engine** создает контейнер (из образа) и передает его в **containerd**.
2. **Containerd** вызывает **containerd-shim**
3. **Containerd-shim** использует **runC** для запуска контейнера
4. **Containerd-shim** позволяет среде выполнения (в данном случае **runC**) завершиться после запуска контейнера
Используя эту новую архитектуру, мы можем запускать «контейнеры без служб» (“daemon-less containers”), и у нас есть два преимущества:
1. **runC** может завершиться после запуска контейнера, и нам не нужны запущенными все процессы исполнения.
2. **containerd-shim** сохраняет открытыми файловые дескрипторы, такие как stdin, stdout и stderr, даже когда Docker и /или containerd завершаются.



==Слои хранения==
![[Screenshot 2024-07-31 093321.png]]

==Слоевая архитектура==
![[Screenshot 2024-07-31 093534.png]]

==Volume==
![[Screenshot 2024-07-31 095901.png]]

## Сеть в Docker

==Сети по умолчанию==
Когда мы устонавливаем Docker он автоматически создает 3 сети:
![[Screenshot 2024-08-01 090451.png]]
Есть еще виды сетей Overlay, Macvlan, 3rdParty Plugins

==Пользовательские сети==
![[Screenshot 2024-08-01 094032.png]]
По умолчанию  здесь создается только 1 внутреняя сеть. Но мы можем сами создать свой собственную внутренюю сеть, использую команду:
```javascript
docker network create --driver тут указываем ту сеть которая нам нужна \ --subnet ip address/16 или другая сеть my-custom-network
```

Команда которая выводит список всех сетей
```javascript
docker network ls
```

==Встроенный DNS==
![[Screenshot 2024-08-01 094944.png]]

## Docker Registry

Docker trusted registry (DTR) позволяет:
- Подпись образов
- Сканирование образов
- Управление образами и заданиями
- Встроенный контроль доступа

Этой командой можно загрузить образ в приватный реджистри:
```javascript
docker push <private-registry-address>/<username>/<repo-name>
```


==Image==
Вот возьмем пример 
```javascript
docker run nginx
```
Когда мы запустили эту команду где
`image: nginx` где:
![[Screenshot 2024-08-01 123041.png]]

Для аунтификации в свой частный риестр:
```javascript
docker login private-registry.io
```

==Развертывание Private Registry==
Что бы развернуть свой собственный частный риестр в своей организации:
```javascript
docker run -d -p 5000:5000 --name registry:2
```

Что бы закачать туда собственный образ:
```javascript
docker image tag my-image localhost:5000/my-image
```
Что бы пометить образ для частного `regestry` 

Для отправления этого образа в свой локальный частный `regestry`
```javascript
docker push localhost:5000/my-image
```

Что бы забрать этот образ:
```javascript
docker pull localhost:5000/my-image
```

==Создание Docker Regestry==

## Оркестрация 

Оркестрация в контексте информационных технологий и DevOps — это процесс автоматизации координации и управления сложными задачами и рабочими процессами в ИТ-инфраструктуре. Оркестрация объединяет различные автоматизированные процессы, управляет их выполнением и координирует взаимодействие между различными компонентами системы. Основные цели оркестрации включают повышение эффективности, уменьшение ошибок и упрощение управления ИТ-инфраструктурой.

==Примеры оркестрации:==

- **Контейнеры**: Управление и координация контейнеризованных приложений с помощью таких инструментов, как Kubernetes.
- **Облачные сервисы**: Автоматизация развертывания и управления ресурсами в облаке с помощью таких инструментов, как AWS CloudFormation или Terraform.
- **CI/CD**: Автоматизация процессов непрерывной интеграции и доставки с использованием Jenkins, GitLab CI/CD и других инструментов.
- **Инфраструктура как код (IaC)**: Управление и автоматизация инфраструктуры через код, например, с помощью Ansible, Puppet или Chef.

==Основные преимущества оркестрации включают:==

- **Скорость и гибкость**: Быстрое развертывание и масштабирование ресурсов.
- **Надежность и стабильность**: Минимизация ошибок за счет автоматизации повторяющихся задач.
- **Экономия времени и ресурсов**: Снижение трудозатрат на управление инфраструктурой.
- **Упрощение сложных процессов**: Удобное управление сложными и многокомпонентными системами.

#### Технологии оркестрации
- Docker swarm
- Kubernetes
- Mesos

## Docker Swarm

С помощь Docker Swarm мы модем собрать несколько Docker хостов в единый кластер 
![[Screenshot 2024-08-02 144241.png]]

Для начала нам нужно одно или несколько машин с установленным Docker, после этого нам нужно определится какой из них будет в роли `Manager` или мастера. Остальные хосты станут своевами или `Worker` 
Далее запустим команду: на `Manager`
```javascript
docker swarm init
```
для инитиализации Manager Swarm
![[Screenshot 2024-08-02 144843.png]]

==Docker Service==
![[Screenshot 2024-08-02 154011.png]]

==Kubernetes==
![[Screenshot 2024-08-02 154327.png]]

==Ноды==
Ноды - это машина, физическая или виртуальная, на которой установлен Kubernetes. 
Кластер предстовляет из себя набор узлов нода 
Кластер - это набор сгруппированных вместе узлов, таким образом, если один из узлов падает, наше приложение все еще доступно для пользователей. 

==Мастер== ( Conter Playen)
Мастер это еще одна нода, член кластера Kubernetes, сконфигурированная как мастер. У нее особые функции, наблюдать за состоянием других нод и быть ответственной за оркестрацию  контейнеров на Worker Нодах. 

==Компоненты==
![[Screenshot 2024-08-02 155907.png]]

- ETCD - Это распределенная надежная база данных, используемая Kubernetes, для хранения всей информации нужной для хранения кластеров 
- API Server - Выступают в качестве фронтендера, единого интерфейса для Kubernetes
- Container runtime - Это базовое программное обеспечение которое используется для запуска контейнера
- Controller - Это мозг оркестрации, они смотрят за состоянием нод, контейнеров. Они принимают решение по созданию новый контейнеров 
- Scheduler - Он ответственен за распределения работ или контейнеров между нодами.  
- Kubelet - Это агент который работает на каждом узле кластера. Он отвечает за то что бы контейнеры работали на узлах должнем образом.

==Kubectl==
Этот инструмент используется для развертывания и управления приложениями в кластере Kubernetes. 
Команыды:
```javascript
kubectl run hello-minikube / развертывание приложения в кластере 
kubectl cluster-info / просмотр информации о кластере
kubectl get nodes / вывод списка всех узлов в кластере 
```