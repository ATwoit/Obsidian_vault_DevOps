
Linux 
![[Pasted image 20241016114503.png]]


## Команды

```javascript
- pwd   /  С помощью команды pwd (расшифровывается как Print Working Directory вывести информацию о рабочей директории)
- cd    / Вы можете изменить вашу текущую директорию с помощью команды cd
- ls    / Вы можете вывести список содержимого директории с помощью утилиты ls.
- ls -a /  Часто используемым параметром утилиты ls является параметр -a, который предназначен для вывода информации обо всех файлах.
- mkdir / создание новой директории
- rmdir / В том случае, если директория пуста, вы можете использовать утилиту для удаления этой директории.
- file  / Утилита file предназначена для определения типа файла
- touch / Создание пустого файла
- rm    / Удаление файлов навсегда
- rm -i / Для того, чтобы застраховаться от случайного удаления файла, вы можете использовать команду
- cp    / Копирование отдельных файлов
- cp -i / Для предотвращения перезаписи существующих файлов в ходе использования утилиты cp следует использовать параметр -i
- mv    / Переименование файлов с помощью утилиты mv
- head  / Вы можете использовать утилиту head для вывода первых десяти строк файла.
- tail  / По аналогии с утилитой head, утилита tail может использоваться для вывода последних десяти строк файла
- cat   / Все, что она делает - это копирует данные из стандартного потока ввода в стандартный поток вывода
- tac   / обратное cat ( Предназначение утилиты tac (в отличие от утилиты cat) может быть проиллюстрировано с помощью единственного примера.)
- more  / Утилита more позволяет ознакомится с содержимым файла, разделенным на страницы.
- less  / more
- strings / С помощью утилиты strings вы можете осуществить вывод читаемых человеком ascii-строк, которые обнаруживаются в бинарных файлах.
- переменная = значение ( variable='что то echo $variable )
- du -h -s  /  выведет сколько мест на диске текущей директории
```
## Переменные
`HISTSIZE` - это количество строк (команд), которые хранятся в памяти во время сессии bash
`Добавление в path` — это процесс добавления новой директории или файла к пути к файлам и папкам на компьютере или веб-сервере.
## Катологи

```javascript
- bin  /  хранятся бинарные файлы ( установка файлов )
- boot /  ядро операционной сисьемы
- dev  /  девайсфы
- etc  / настройка программ
- home /домашний католог
- lib  / библиотека
- lost+found  / информация о повреждении файловой системы
- media / католог для монтирования
- mnt  / временный католог для монтирования
- opt  / хранятся нам нужные вещи
- proc / отоброжает все процессы, все программы работающие на сервере
- root / католог для супер пользователя
- run  / хранение временных файлов
- sbin / 
- snap /
- srv  / 
- sys  / 
- tmp  / 
- var  / 
- usr  / 
```

## Ввод / Вывод

Программа < файл брать stdin из файла
Программа > файл выводить stdout в файл
Программа >> файл аналогично, но с дозаписью в файл
Программа 2> файл выводить stderr в файл Программа 2>> файл аналогично, но с дозаписью в файл
## Конвейер ( pipe )

```javascript
Прог1 | Прог2 | ... | Прогn
Передать stdout Прог1 в качестве stdin lkz Прог2, далее stdout Прог2 в качестве stdin для Прог3 и тд
```

## Скачивания файла
- wget ссылка ( скачать файл по ссылке и сохранить в текущей директории
- wget - P путь_до_директории ссылка ( скачать файл по ссылке и сохронить в директории заданной путем
- wget -O путь_до_файла ссылка (скачать файл по ссылке и сохранить под указанным именем
- wget -c ссылка ( докачать файл по ссылке в случае обрыва связи )
- wget --spider ссылка ( проверить доступность файла по ссылке )
- wget -i текстовый_файл ( скачаьб несколько файлов по ссылкам из текстового файлы )
- wget -r -l глубина сслыка ( рекурсивное скачивание файлов по ссылке на указанную глубину [ по умолчанию глубина 5 ]
- wget -r -A mun,mun,mun,...,mun ссылка ( рекурсивное скачивание файлов только определенного типа или типов )
## Работа с архивами
1. Распаковка архивов
     - gunzip архив.gz ( распаковать содержимое архива.gz, файл архив.gz удалить )
     - unzip архив.zip ( распаковать содеражание архива.zip )
     - tar -xvf архив.tar ( распаковать архив.tar )
     - tar -xzvf архив.tar.gz (распаковать архив.tar.gz [ с использованием gunzip ] )
2. Создание архивов
     - zip архив.zip файл1 файл2 ... ( запаковать перечисленные файлы и/или папки в архив.zip )
     - gzip файл ( запаковать файл в файл.gz, исходный файл удалить )
     - tar -cvf архив.tar файл1 файл2 ... ( запаковать перечисленный файлы и/или папки в архив.tar [ без сжатия ] )
     - gzip архив.tar ( запаковать архив.tar в архив.tar.gz , исходный архив.tar удалить )
     - tar -zcvf архив.tar.gz файл1 файл2 ... ( запаковать перечисленные файлы и/или папки в архив.tar.gz [ c сжатием при помощи gzip ] )

| *Команда*                                               | *Описание*                                         |
| ------------------------------------------------------- | -------------------------------------------------- |
| tar -cvf archive.tar /path/to/files                     | Создать архив из файлов и директорий               |
| tar -czvf archive.tar.gz /path/to/files                 | Создать сжатый архив с помощью gzip                |
| tar -xvf archive.tar                                    | Извлечь файлы из архива                            |
| tar -xzvf archive.tar.gz                                | Извлечь файлы из сжатого архива (gzip)             |
| tar -tvf archive.tar                                    | Показать содержимое архива                         |
| tar -xvf archive.tar -C /path/to/extract                | Извлечь файлы в указанную директорию               |
| tar -cvf archive.tar --exclude='pattern' /path/to/files | Исключить файлы или директории при создании архива |

## Поиск файлов и слов в файлах
- find ,<папка> -name "< имя файла >" ( найти указанный файл в папке )
- find ~/ -name "file.txt" ( найти file.txt домашней директории )
- find ~/ -name "*.txt" ( найти все текстовые файлы в домашней директории )
- grep "<строка>" <файл> ( найти строку в файле )
- grep -c "<строка>" <файл> ( посчитать количество вхождений строки )
- grep -r "<строка>" <папка> ( найти строку во всех файлах в папке )
- find -iname "<имя файла>"
не учитывая регистр
- find -path "<путь>"
найти указанный путь
- find -size <размер>
выводить файлы указанного размера
- find -maxdepth <число>
искать не больше чем на заданное число уровней вниз
- find -mindepth <число>
искать начиная с заданного число уровней вниз
- grep -l "<строка>"<файл>
список файлов с этой строкой
- grep -L "<строка>"<файл>
список файлов, где этой строки нет
- grep -n "<строка>"<файл>
выводить номер строки в файле
- grep -m <число> "<строка>"<файл>
не искать дальше после заданного числа вхождений
- grep -A <число> "<строка>" <файл>
выводить это число строк после вхождения
- grep -B <число> "<строка>" <файл>
выводить это число строк до вхождения
- grep -C <число> "<строка>" <файл>
выводить это число строк вокруг вхождения
- grep -E "<шаблон>" <файл>
найти указанный шаблон в файле
- grep -E "^go" <файл>
найти строки, начинающиеся с "go"
- grep -E "go$" <файл>
найти строки, окончивающиеся на "go"
- grep -E "[a-z]+right" <файл>
слова из 5 и более букв, кончающиеся на "right"
- grep -E "[a-z]?right" <файл>
слова из 4-5 букв, кончающие на "right"
- grep -E "[a-zA-Z]* ight" <файл>
слова, кончающиеся на "ight" (разрешены большие буквы)
- cat <файл> | sed 'инструкция'
- sed 'инструкция' <файл>
потоковый редактор: читает строчки из stdin (или из файла), обрабатывает их по инструкции и пишет в stdout
==Если хотим писать в файл==
```bash
><файл>  #обычное перенаправление
-i, --in-place #перезаписать входной файл
```

==Замена слов или текста==
- sed 's/John/Nick/g' old.txt > new.txt
заменить все John на Nick
- sed -r's/J[a-z]* /Nick/g' old.txt > new.txt
заменить все слова, которые начинаются на J и кончается на n на Nick

- sed -n '2.4p' filt.txt
вывести строки с 2 по 4
- sed '2,4d' file.txt
вывести все строки кроме 2-4
- sed -n '/[0-9]\{2\}/p' file.txt
вывести строки с 2 цифрами подряд
- sed '2,/[Rr]ight/d' file.txt
вывести все строки кроме со 2 до строки содержащей "right" (с большой или маленькой буквы)
## Работа на сервере 
1. Вход на сервер 
    - Команда входа: ssh логин@адрес_сервер -p порт 
    - ~/.ssh/id_rsa
    - ~/.ssh/id_rsa.pub
    - ~/.ssh/authorized_keys
2. Обмен файлами 
    - Копирование файлов: 
         - scp -P порт ( логин@адрес_сервера:путь1 путь2 ( с сервера [путь1] на клиента [путь2] ) ) 
         - scp -P порт ( путь1 логин@адрес_сервера:путь2 ( с сервера [путь1] на клиента  [путь2] ))
    - Установка программ через терминал:
         - sudo apt-get install программа 
    - Удаление программ через терминал 
         - sudo pat-get remove программа 
    - Обновление ссылок на пакеты: 
         - sudo apt-get update 
    - Обновление установленных пакетов: 
         - sudo apt-get upgrade 
    - Обновление отдельной программы: 
         - sudo apt-get install --only-upgarde прорамма 
3. Контроль запускаемых программ 
     - Ctrl + С ( прервать выполнение )
     - Ctrl + Z ( приостоновить выполнение )
     - fg ( продолжить [ foreground ])
     - bg ( продолжить в фоновом режиме [ background ])
     - jobs ( просмотреть запущенные программы )
     - fg %<номер> ( продолжить программу с этим номером )
     - bg %<номер> ( продолжить программу с этим номером в фоновом режиме )
     - ps ( просмотреть ваши процессы )
     - top ( отслеживать процессы в реальном времени )
     - top -u <имя пользователя> ( отслеживать процессы этого пользователя )
     - kill <номер процесса> ( завершить процессы с этим номером )
     - kill -9 <номер процесса> ( "убить" процесс с этим номером )
4. Многопоточные приложения 
     - free -g ( информация об оперативной памяти )
     - nproc ( количество ядер процессора )
     - lscpu ( детальная информация о процессе )
     - bowtie2-build ( запуск построения индекса генома )
     - bowtie2-build <геном> <индекс>
     - bowtie2-build ref.fasta index 
     - bowtie ( запуск выравнивателя bowtie )
     - bowtie2 -x <> -U <>
     - bowtie2 -x index -U reads.fastq 
     - bowtie2 -x <индекс> -U <риды>
     -               -p <количество потоков>
     - bowtie2 -x indrx -U reads.fastq -p 4 
5. Менеджер терминалов tmux 
     - Ctrl + Shift + T ( открыть новую вкладку в терминале )
     - Alt + <> ( перейти в указанную вкладку )
     - Ctrl + Shift + W ( закрыть текущую вкладку )
     - tmux ( запустить tmux )
     - Ctrl + B ( перейти в режим команд )
     - Ctrl + B +C ( создать новую вкладку )
     - Ctrl + B + <цифра> ( перейти в указанную вкладку )
     - Ctrl + B + N / Ctrl + B + P ( перейти в следующую / предыдущую вкладку )
     - Ctrl + B + X [или exit] ( закрыть вкладку )
     - Ctrl + B +D ( временно выйти из tmux )
     - tmux attach / tmux a ( вернуться в tmux )
     - tmux list-sessions ( просмотреть список запущенных tmux'ов )
     - Ctrl + B + PgUp ( перейти в режим просмотра истории )
     - PgUp, PgDown, стрелки ( перемещать курсор по истории )
     - Esc, Ctrl + C ( выйти из режима просмотра истории )
## Текстовый редактор и bash
1. Текстовый редактор vim 
    1. Вход:
         - vim 
         - vim файл
         - vim файл1 файл2 файл3 ...
    2. Главные команды:
         - :q ( выход )
         - :help ( справка )
    3. vimtutor
    4. Режимы работы:
         - normal 
             - режим по умолчанию
             - любая клавиша воспринимается как команда
             - << Сложные >> команды начинаются с ':'
         - insert
             - режим ввода текста - все, что вы нажимаете, вставляется (заменяется)
             - выход через < Esc >, < Ctrl+c >
         - visual
             - режим выделения 
    5. Перемещение 
         - По символам: 
             - Стрелочки 
             - h, j, k, l
         - По словам:
             - w, W - в начало следующего слова
             - e, E - в конец 
             - b, B - в начало предыдущего
         - Еще крупнее:
             - 0, ^, $ - начало строки, первый непроблемный символ, конец строки 
         - Совсем крупно: 
             - gg - начало файла
             - G - конец
             - :21< Enter > - перейти к строке 21
             - < Ctrl + D >, < Ctrl + U > - вниз/вверх на N строчек, где N обычно пол-экрана 
    6. Удаление 
         - По символам: 
             - x - символ под курсором
             - X - символ до курсора
         - Сразу много: d [<кол-во>] <ход>
             - de - удалить до конца текущего слова
             - d$ - удалить до конца строки
             - d5w - удалить пять слов
         - Специально команда: 
             - dd - удалить строку ( или, например, d10d )
    7. Создание 
         - i - войти в insertion mode
         - a - сдвинуть курсор вправо и войти в insertion mode 
         - l = ^ i
         - A = $a
         - o - вставить пустую строку снизу и редактировать ее
         - O - то же, но строка сверху
    8. Копирование 
         - Скопировать: 
             - y <кол-во> <ход> - скопировать
             - yy - скопировать строку
         - Вставить:
             - p - вставить перед 
             - P - вставить после 
    9. Поиск и замена 
         - Поиск: 
             - /<текст> - искать <текст> вперед
             - ?<текст> - назад
             - n - следующее вхождение , N - предыдущее
         - Замена:
             - :%s/<что ищем>/<на что меняем>/<флаги>
             - флаги: g - много замен с троке, c - подтверждение 
    10. Полезные команды
         - Отмена/возврат: 
             - u - отменить последнее действие
             - < Ctrl +r > - вернуть отменное действие
         - Сохраненные работы:
             - :w - сохранить изменения 
	         - :wq - сохранить и выйти 
             - :q! - выйти без сохранения
             - :w <файл> - сохранить изменения в <файл>
2. Програмvирование на bash 
    - Первая программа:
         - Создаем программу:
         - vim my_first_script.sh
         - #!/bin/bash
         - echo "hello, world!"
         - Запускаем программу:
         - chmod +x my_first_scrip.sh ./my_first_script.sh
    - Переменные 
        - Переменные ( variable ) 
             - именованная область памяти 
        - имя ( name ) 
             - буквы, цифры, _;
             - не может начинаться с цифры 
        - значение ( value )
             - числа;
             - строки ( если есть пробелы, то в кавычказ ):
             - отдельные символы.
        - Запись ( перезапись ) значения 
             - <имя>=<значение>
             - path=~/Docs
        - Чтение: 
             - $<> ${<>}
             - path2=$path/file.txt           # path2=~/Docs/file1.txt
             - echo "Path is $path2"         # Path is~/Docs/file1.txt
             - echo "Path is ${path}2"       # Path is~/Docs2
    - Аргументы 
        - Передача аргументов скрипту
             - ./script.sh arg1 arg2 arg3 ...
        - Обработка внутри скрипта 
             - $1 первый аргумент 
             - $2 второй аргумент 
             - .....
             - $0 имя скрипта 
             - $# количество аргумента 
             - var="Первый аргумент равен $1"
             - echo "Всего было передано $# аргументов"
    - Ветвление: основы 
         - Синтаксис 
             - if [ [ условия ] ]
             - then 
             -          # действия, если условие истинно
             - fi 
         - Условия ( строки ):
             - -z <строка> # строка пуста
             - -n <строка> # строка не пуста
             - <стр1> == <стр2> # строки равны 
             - <стр1>  != <стр2> # строки не равны 
         - Пример:
             - if [ [ -z $1 ] ]
             - then 
             -         echo "Первый аргумент пустой!"
             - fi 
             - if [ [ $var1 == $var2 ] ]
             - then
             -        echo "Переменные равны!"
             - fi
         - Условия ( файлы )
             - -e <путь>  #   путь существует
             - -f <путь>   #   это файл 
             - -d <путь>  #   это директория
             - -s <путь>  #   размер файла больше 0 
             - -x <путь>  #   файл исполняемый 
         - Условия ( логические ):
             - !        #   отрицание логического выражения 
             - &&   #  логическое <<и>>
             - | |      #  логическое <<или>>
         - Подсказки 
             - $0 # имя скрипта
            -z < string >        # string empty  
            -n < string >       # string not empty  
            -eq, ( == )           # равно  
            -ne, (!=)               # не равно  
            -lt, (<)                  # меньше  
            -le,                       # меньше или равно  
            -gt, (>)                 # больше  
            -ge,                      # больше или равно  
            -e < path >          # путь существует  
            -f < path >           # это файл  
            -d < path >          # это директория  
            -s < path >          # разм файла больше 0 
            -p                         # упрощение кода, что бы не писать два раза echo 
            -x < path >          # файл исполняемый
         - Ветвление: альтернативы
             - Синтаксис: 1 
                 - if [ [ условеи ] ]
                 - then 
                 -        # действие, если условие истинно 
                 - else 
                 -        # действие, если условие ложно
             - Синтаксис: 2
                 - if [ [ условие1 ] ]
                 - then 
                 -        # действия, если условие1 истинно
                 - elif [ [ условие 2] ]
                 - then
                 -      # действия, если условие 1 истинно
                 -      # но условие2 истинно
                 - else
                 -       # действия, если обы условия ложны
                 - fi
             - Синтаксис: 3
                 - case переменная in
                 - знач1)
                 -     # действия, если переменная== знач1
                 -      ; ;
                 - знач2)
                 -     # действия, если переменная== знач2
                 -      ; ;
                 - * )
                 -     # действия, если переменная
                 -     # не равна ни одному из вариантов
                 - esac
         - Циклы
             - Синтаксис:
                 - for переменная in список_значений 
                 - do 
                 (#) действия, каждый раз переменная 
                 (#) принимает следующее значение
                 (#) из списка 
                 - done 
                 - break прервать выполнение 
                 - continue перейти на след. значение
             - Синтаксис:
                 - while [ [ условие ] ]
                 - do
                 (#) действия, пока условие истинно
                 - done
                 - read переменная 
                 записать введенное пользователем значение в переменную 
    - Арифметика
         ==Синтаксис:== 
         - let "переменная = выражение"
         ==Пример==
         - let "c=1+1"
         - let "c=a+b"
         ==Операции==
         - +,-,/,* - стандартные 
         - % - остаток от деления
         - ** - возведение в степень 
         ==Сокращение==
         - let "a=a+b" эквивалент let "a+=b"
    - Внешние программы
         ==Синтаксис==
         - переменная= `программа`
         ==Пример==
         - a=`echo "test"`
         - files=`ls ~`
         ==Код возврата==
         - 0 корректное завершение
         - не 0 п процессе работы были ошибки 
         ==Узнать код==
         - $?
         ==Выйти с кодом==
         - exit код
         ==Пример==
         - touch file.txt
         - echo $?
         ==Проверка кода возврата==
         if `программа`
         действия, если код 0
         then
         else
         действия, если код не 0
    - Функции
         ==1.== Задаем функцию:
         имя_функции ()
         {
         действия
         }
         Используем функцию:
         . . .
         имя_функции
         . . . 
         ==2.== Функции с параметром:
         имя_функции ()
         {
         действия с $1, $2, ... , $#
         }
         Используем функцию:
         . . .
         имя_функции аргумент1 аргумент2 . . .
         ==3.== Переменные:
         имя_функции ()
         {
         var_global=1
         local var_local=1
         }
         Используем:
         имя_функции
         echo $var_global / выведет 1
         echo $var local    / ничего не выведет
         ==4.== Компактная запись:
         имя_функции () { действ1; действ2; }
         ==5.== Актуально и в других конструкциях:
         if [ [ $var==''test ''] ] ; then
         . . .
         for i in 1 2 3 4 5; do
         . . .
## Soft Link / Hard Link
1.  ==Жесткие ссылки (Hard Links)==

Жесткая ссылка – это дополнительное имя для существующего файла. Она указывает на один и тот же `inode` (индексный дескриптор), что означает, что файл будет доступен по обоим именам, и изменения в одном файле отразятся в другом.

#пример
```bash
ln file1 file2
```
После выполнения этой команды `file1` и `file2` будут указывать на один и тот же файл на уровне файловой системы. Удаление одного из них не затронет содержимое файла, пока остается хотя бы одна ссылка.

2. ==Символические ссылки (Symbolic Links)==

Символическая ссылка – это специальный файл, который содержит путь к другому файлу или директории. Символические ссылки могут указывать на файлы и директории, а также на файлы на других файловых системах или устройствах.

#пример 
```bash
ln -s file1 file2
```
Здесь `file2` будет символической ссылкой на `file1`. Удаление оригинального файла приведет к "сломанной" ссылке, так как символическая ссылка указывает на имя файла, а не на его содержимое.

3. ==Основные опции команды `ln`==

- `-s`: Создать символическую ссылку вместо жесткой.
- `-f`: Принудительно создать ссылку, удалив существующие файлы с таким же именем.
- `-v`: Вывести на экран информацию о процессе создания ссылки (verbose).
- `-n`: Не разыменовывать символические ссылки.
## Новые команды
1. ==Посчитать что-то в файле:==
wc -l <имя файла> вывести количество строк
wc -c <имя файла> вывести количество байт
wc -m <имя файла> вывести количество символов
wc -L <имя файла> вывести длину самой длинной строки
wc -w <имя файла> вывести количество слов

3. ==Сравнить файлы / директории:==
diff [-q -r] <путь1> <путь2>
diff file.txt file2.txt | less
diff -qr dir1/ dir2/

3. ==Узнать сколько места занимаем на диске:==
du [--max-depth <глубина> -h] <путь>
du -h ~/
du --max-depth 1 -h
df [-h]
узнать сколько места занято/свободно во всей системе

4. ==Вывести часть файла:==
head [-n <количество строк>] <путь>
tail [-n <количество строк>] <путь>
head -n 10 file.txt
tail -n 50 file.txt | less

## Справочная литература 
- [http://rus-linux.net/](http://rus-linux.net/ "Link: http://rus-linux.net/")  -- виртуальная энциклопедия ﻿Linux ﻿  
- ﻿[http://www.f-notes.info/linux:linux_command](http://www.f-notes.info/linux:linux_command "Link: http://www.f-notes.info/linux:linux_command") -- довольно обширный список полезных команд терминала.
- ﻿[http://ru.najomi.org/_nix](http://ru.najomi.org/_nix "Link: http://ru.najomi.org/_nix") -- полезные примеры использования команд терминала
- ﻿[http://forum.ubuntu.ru/](http://forum.ubuntu.ru/ "Link: http://forum.ubuntu.ru/") -- форум русскоязычного сообщества Ubuntu.
- [http://ru.najomi.org/vim](http://ru.najomi.org/vim "Link: http://ru.najomi.org/vim") -- команды vim  
- ﻿[http://lib.ru/LINUXGUIDE/torvalds_jast_for_fun.txt](http://lib.ru/LINUXGUIDE/torvalds_jast_for_fun.txt "Link: http://lib.ru/LINUXGUIDE/torvalds_jast_for_fun.txt") -- книга создателя Linux Линуса Торвальдса "Just for fun".
## Новый команды с примерами и обьяснением
==1. ==
#пример 
```bash
sudo update-grub
```

1. Сканирование системы на наличие операционных систем и ядер Linux:
2. Обновление конфигурационного файла:

Что должно выйти после команды
```javascript
Generating grub configuration file ...
Found linux image: /boot/vmlinuz-5.4.0-26-generic
Found initrd image: /boot/initrd.img-5.4.0-26-generic
Found linux image: /boot/vmlinuz-5.4.0-24-generic
Found initrd image: /boot/initrd.img-5.4.0-24-generic
Found Windows 10 on /dev/sda1
Adding boot menu entry for UEFI Firmware Settings
done
```
==2.==
#пример 
```bash
renice +5 -p
```
Команда `renice` в Linux используется для изменения приоритета выполнения уже запущенного процесса

==3.==

## SSH для Linux 

Ссылка для SSH - https://www.youtube.com/watch?v=Ugek2bOLRRk

==1)== В большинстве дистрибутивов Linux SSH сервер устанавливается по умолчанию, но если вы не уверены, можно установить его командой:

```bash
sudo apt update 
sudo apt install openssh-server
```

==2)== Проверка статуса SSH-сервера
```bash
sudo systemctl status ssh
```

==3)== Запуск службы
```bash
sudo systemctl start ssh 
sudo systemctl enable ssh
```

==4)== Настройка брандмауэра (если необходимо)
```bash
sudo ufw allow ssh 
sudo ufw enable
```

==5)== Подключение по SSH:
```bash
ssh username@ip_address
```
Замените `username` на ваше имя пользователя на виртуальной машине и `ip_address` на IP-адрес вашей виртуальной машины.

==6)== Или же подключится с помощью утилит таких как Putty или Mobaxtern:
Просто вводим IP address и входим в нашу виртуальную машину
